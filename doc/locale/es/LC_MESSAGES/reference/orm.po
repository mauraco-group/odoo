# SOME DESCRIPTIVE TITLE.
# Copyright (C) Odoo S.A.
# This file is distributed under the same license as the odoo package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: odoo 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-07-17 21:50-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../reference/orm.rst:7
msgid "ORM API"
msgstr ""

#: ../../reference/orm.rst:10
msgid "Recordsets"
msgstr ""

#: ../../reference/orm.rst:14
msgid ""
"This page documents the New API added in Odoo 8.0 which should be the "
"primary development API going forward. It also provides information about"
" porting from or bridging with the \"old API\" of versions 7 and earlier,"
" but does not explicitly document that API. See the old documentation for"
" that."
msgstr ""

#: ../../reference/orm.rst:19
msgid ""
"Interaction with models and records is performed through recordsets, a "
"sorted set of records of the same model."
msgstr ""

#: ../../reference/orm.rst:22
msgid ""
"contrary to what the name implies, it is currently possible for "
"recordsets to contain duplicates. This may change in the future."
msgstr ""

#: ../../reference/orm.rst:25
msgid ""
"Methods defined on a model are executed on a recordset, and their "
"``self`` is a recordset::"
msgstr ""

#: ../../reference/orm.rst:35
msgid ""
"Iterating on a recordset will yield new sets of *a single record* "
"(\"singletons\"), much like iterating on a Python string yields strings "
"of a single characters::"
msgstr ""

#: ../../reference/orm.rst:45
msgid "Field access"
msgstr ""

#: ../../reference/orm.rst:47
msgid ""
"Recordsets provide an \"Active Record\" interface: model fields can be "
"read and written directly from the record as attributes, but only on "
"singletons (single-record recordsets). Field values can also be accessed "
"like dict items, which is more elegant and safer than ``getattr()`` for "
"dynamic field names. Setting a field's value triggers an update to the "
"database::"
msgstr ""

#: ../../reference/orm.rst:63
msgid "Trying to read or write a field on multiple records will raise an error."
msgstr ""

#: ../../reference/orm.rst:65
msgid ""
"Accessing a relational field (:class:`~odoo.fields.Many2one`, "
":class:`~odoo.fields.One2many`, :class:`~odoo.fields.Many2many`) *always*"
" returns a recordset, empty if the field is not set."
msgstr ""

#: ../../reference/orm.rst:71
msgid ""
"each assignment to a field triggers a database update, when setting "
"multiple fields at the same time or setting fields on multiple records "
"(to the same value), use :meth:`~odoo.models.Model.write`::"
msgstr ""

#: ../../reference/orm.rst:89
msgid "Record cache and prefetching"
msgstr ""

#: ../../reference/orm.rst:91
msgid ""
"Odoo maintains a cache for the fields of the records, so that not every "
"field access issues a database request, which would be terrible for "
"performance. The following example queries the database only for the "
"first statement::"
msgstr ""

#: ../../reference/orm.rst:98
msgid ""
"To avoid reading one field on one record at a time, Odoo *prefetches* "
"records and fields following some heuristics to get good performance. "
"Once a field must be read on a given record, the ORM actually reads that "
"field on a larger recordset, and stores the returned values in cache for "
"later use. The prefetched recordset is usually the recordset from which "
"the record comes by iteration. Moreover, all simple stored fields "
"(boolean, integer, float, char, text, date, datetime, selection, "
"many2one) are fetched altogether; they correspond to the columns of the "
"model's table, and are fetched efficiently in the same query."
msgstr ""

#: ../../reference/orm.rst:107
msgid ""
"Consider the following example, where ``partners`` is a recordset of 1000"
" records. Without prefetching, the loop would make 2000 queries to the "
"database. With prefetching, only one query is made::"
msgstr ""

#: ../../reference/orm.rst:116
msgid ""
"The prefetching also works on *secondary records*: when relational fields"
" are read, their values (which are records) are  subscribed for future "
"prefetching. Accessing one of those secondary records prefetches all "
"secondary records from the same model. This makes the following example "
"generate only two queries, one for partners and one for countries::"
msgstr ""

#: ../../reference/orm.rst:128
msgid "Set operations"
msgstr ""

#: ../../reference/orm.rst:130
msgid ""
"Recordsets are immutable, but sets of the same model can be combined "
"using various set operations, returning new recordsets. Set operations do"
" *not* preserve order."
msgstr ""

#: ../../reference/orm.rst:136
msgid ""
"``record in set`` returns whether ``record`` (which must be a 1-element "
"recordset) is present in ``set``. ``record not in set`` is the inverse "
"operation"
msgstr ""

#: ../../reference/orm.rst:139
msgid ""
"``set1 <= set2`` and ``set1 < set2`` return whether ``set1`` is a subset "
"of ``set2`` (resp. strict)"
msgstr ""

#: ../../reference/orm.rst:141
msgid ""
"``set1 >= set2`` and ``set1 > set2`` return whether ``set1`` is a "
"superset of ``set2`` (resp. strict)"
msgstr ""

#: ../../reference/orm.rst:143
msgid ""
"``set1 | set2`` returns the union of the two recordsets, a new recordset "
"containing all records present in either source"
msgstr ""

#: ../../reference/orm.rst:145
msgid ""
"``set1 & set2`` returns the intersection of two recordsets, a new "
"recordset containing only records present in both sources"
msgstr ""

#: ../../reference/orm.rst:147
msgid ""
"``set1 - set2`` returns a new recordset containing only records of "
"``set1`` which are *not* in ``set2``"
msgstr ""

#: ../../reference/orm.rst:151
msgid "Other recordset operations"
msgstr ""

#: ../../reference/orm.rst:153
msgid ""
"Recordsets are iterable so the usual Python tools are available for "
"transformation (:func:`python:map`, :func:`python:sorted`, "
":func:`~python:itertools.ifilter`, ...) however these return either a "
":class:`python:list` or an :term:`python:iterator`, removing the ability "
"to call methods on their result, or to use set operations."
msgstr ""

#: ../../reference/orm.rst:159
msgid ""
"Recordsets therefore provide these operations returning recordsets "
"themselves (when possible):"
msgstr ""

#: ../../reference/orm.rst:171
msgid ":meth:`~odoo.models.Model.filtered`"
msgstr ""

#: ../../reference/orm.rst:163
msgid ""
"returns a recordset containing only records satisfying the provided "
"predicate function. The predicate can also be a string to filter by a "
"field being true or false::"
msgstr ""

#: ../../reference/orm.rst:178
msgid ":meth:`~odoo.models.Model.sorted`"
msgstr ""

#: ../../reference/orm.rst:174
msgid ""
"returns a recordset sorted by the provided key function. If no key is "
"provided, use the model's default sort order::"
msgstr ""

#: ../../reference/orm.rst:196
msgid ":meth:`~odoo.models.Model.mapped`"
msgstr ""

#: ../../reference/orm.rst:181
msgid ""
"applies the provided function to each record in the recordset, returns a "
"recordset if the results are recordsets::"
msgstr ""

#: ../../reference/orm.rst:187
msgid "The provided function can be a string to get field values::"
msgstr ""

#: ../../reference/orm.rst:199
msgid "Environment"
msgstr ""

#: ../../reference/orm.rst:201
msgid ""
"The :class:`~odoo.api.Environment` stores various contextual data used by"
" the ORM: the database cursor (for database queries), the current user "
"(for access rights checking) and the current context (storing arbitrary "
"metadata). The environment also stores caches."
msgstr ""

#: ../../reference/orm.rst:206
msgid ""
"All recordsets have an environment, which is immutable, can be accessed "
"using :attr:`~odoo.models.Model.env` and gives access to the current user"
" (:attr:`~odoo.api.Environment.user`), the cursor "
"(:attr:`~odoo.api.Environment.cr`) or the context "
"(:attr:`~odoo.api.Environment.context`)::"
msgstr ""

#: ../../reference/orm.rst:219
msgid ""
"When creating a recordset from an other recordset, the environment is "
"inherited. The environment can be used to get an empty recordset in an "
"other model, and query that model::"
msgstr ""

#: ../../reference/orm.rst:229
msgid "Altering the environment"
msgstr ""

#: ../../reference/orm.rst:231
msgid ""
"The environment can be customized from a recordset. This returns a new "
"version of the recordset using the altered environment."
msgstr ""

#: ../../reference/orm.rst:245
msgid ":meth:`~odoo.models.Model.sudo`"
msgstr ""

#: ../../reference/orm.rst:235
msgid ""
"creates a new environment with the provided user set, uses the "
"administrator if none is provided (to bypass access rights/rules in safe "
"contexts), returns a copy of the recordset it is called on using the new "
"environment::"
msgstr ""

#: ../../reference/orm.rst:257
msgid ":meth:`~odoo.models.Model.with_context`"
msgstr ""

#: ../../reference/orm.rst:248
msgid ""
"can take a single positional parameter, which replaces the current "
"environment's context"
msgstr ""

#: ../../reference/orm.rst:250
msgid ""
"can take any number of parameters by keyword, which are added to either "
"the current environment's context or the context set during step 1"
msgstr ""

#: ../../reference/orm.rst:260
msgid ":meth:`~odoo.models.Model.with_env`"
msgstr ""

#: ../../reference/orm.rst:260
msgid "replaces the existing environment entirely"
msgstr ""

#: ../../reference/orm.rst:263
msgid "Common ORM methods"
msgstr ""

#: ../../reference/orm.rst:279
msgid ":meth:`~odoo.models.Model.search`"
msgstr ""

#: ../../reference/orm.rst:268
msgid ""
"Takes a :ref:`search domain <reference/orm/domains>`, returns a recordset"
" of matching records. Can return a subset of matching records (``offset``"
" and ``limit`` parameters) and be ordered (``order`` parameter)::"
msgstr ""

#: ../../reference/orm.rst:278
msgid ""
"to just check if any record matches a domain, or count the number of "
"records which do, use :meth:`~odoo.models.Model.search_count`"
msgstr ""

#: ../../reference/orm.rst:286
msgid ":meth:`~odoo.models.Model.create`"
msgstr ""

#: ../../reference/orm.rst:282
msgid ""
"Takes a number of field values, and returns a recordset containing the "
"record created::"
msgstr ""

#: ../../reference/orm.rst:292
msgid ":meth:`~odoo.models.Model.write`"
msgstr ""

#: ../../reference/orm.rst:289
msgid ""
"Takes a number of field values, writes them to all the records in its "
"recordset. Does not return anything::"
msgstr ""

#: ../../reference/orm.rst:301
msgid ":meth:`~odoo.models.Model.browse`"
msgstr ""

#: ../../reference/orm.rst:295
msgid ""
"Takes a database id or a list of ids and returns a recordset, useful when"
" record ids are obtained from outside Odoo (e.g. round-trip through "
"external system) or :ref:`when calling methods in the old API "
"<reference/orm/oldapi>`::"
msgstr ""

#: ../../reference/orm.rst:315
msgid ":meth:`~odoo.models.Model.exists`"
msgstr ""

#: ../../reference/orm.rst:304
msgid ""
"Returns a new recordset containing only the records which exist in the "
"database. Can be used to check whether a record (e.g. obtained "
"externally) still exists::"
msgstr ""

#: ../../reference/orm.rst:311
msgid "or after calling a method which could have removed some records::"
msgstr ""

#: ../../reference/orm.rst:322
msgid ":meth:`~odoo.api.Environment.ref`"
msgstr ""

#: ../../reference/orm.rst:318
msgid ""
"Environment method returning the record matching a provided "
":term:`external id`::"
msgstr ""

#: ../../reference/orm.rst:330
msgid ":meth:`~odoo.models.Model.ensure_one`"
msgstr ""

#: ../../reference/orm.rst:325
msgid ""
"checks that the recordset is a singleton (only contains a single record),"
" raises an error otherwise::"
msgstr ""

#: ../../reference/orm.rst:333
msgid "Creating Models"
msgstr ""

#: ../../reference/orm.rst:335
msgid "Model fields are defined as attributes on the model itself::"
msgstr ""

#: ../../reference/orm.rst:343
msgid ""
"this means you can not define a field and a method with the same name, "
"they will conflict"
msgstr ""

#: ../../reference/orm.rst:346
msgid ""
"By default, the field's label (user-visible name) is a capitalized "
"version of the field name, this can be overridden with the ``string`` "
"parameter::"
msgstr ""

#: ../../reference/orm.rst:351
msgid ""
"For the various field types and parameters, see :ref:`the fields "
"reference <reference/orm/fields>`."
msgstr ""

#: ../../reference/orm.rst:354
msgid "Default values are defined as parameters on fields, either a value::"
msgstr ""

#: ../../reference/orm.rst:358
msgid ""
"or a function called to compute the default value, which should return "
"that value::"
msgstr ""

#: ../../reference/orm.rst:366 odoo.fields.Field:43 of
msgid "Computed fields"
msgstr ""

#: ../../reference/orm.rst:368
msgid ""
"Fields can be computed (instead of read straight from the database) using"
" the ``compute`` parameter. **It must assign the computed value to the "
"field**. If it uses the values of other *fields*, it should specify those"
" fields using :func:`~odoo.api.depends`::"
msgstr ""

#: ../../reference/orm.rst:381
msgid "dependencies can be dotted paths when using sub-fields::"
msgstr ""

#: ../../reference/orm.rst:388
msgid ""
"computed fields are not stored by default, they are computed and returned"
" when requested. Setting ``store=True`` will store them in the database "
"and automatically enable searching"
msgstr ""

#: ../../reference/orm.rst:391
msgid ""
"searching on a computed field can also be enabled by setting the "
"``search`` parameter. The value is a method name returning a "
":ref:`reference/orm/domains`::"
msgstr ""

#: ../../reference/orm.rst:402
msgid ""
"to allow *setting* values on a computed field, use the ``inverse`` "
"parameter. It is the name of a function reversing the computation and "
"setting the relevant fields::"
msgstr ""

#: ../../reference/orm.rst:418
msgid ""
"multiple fields can be computed at the same time by the same method, just"
" use the same method on all fields and set all of them::"
msgstr ""

#: ../../reference/orm.rst:433 odoo.fields.Field:110 of
msgid "Related fields"
msgstr ""

#: ../../reference/orm.rst:435
msgid ""
"A special case of computed fields are *related* (proxy) fields, which "
"provide the value of a sub-field on the current record. They are defined "
"by setting the ``related`` parameter and like regular computed fields "
"they can be stored::"
msgstr ""

#: ../../reference/orm.rst:443
msgid "onchange: updating UI on the fly"
msgstr ""

#: ../../reference/orm.rst:445
msgid ""
"When a user changes a field's value in a form (but hasn't saved the form "
"yet), it can be useful to automatically update other fields based on that"
" value e.g. updating a final total when the tax is changed or a new "
"invoice line is added."
msgstr ""

#: ../../reference/orm.rst:450
msgid ""
"computed fields are automatically checked and recomputed, they do not "
"need an ``onchange``"
msgstr ""

#: ../../reference/orm.rst:452
msgid ""
"for non-computed fields, the :func:`~odoo.api.onchange` decorator is used"
" to provide new field values::"
msgstr ""

#: ../../reference/orm.rst:460
msgid ""
"the changes performed during the method are then sent to the client "
"program and become visible to the user"
msgstr ""

#: ../../reference/orm.rst:463
msgid ""
"Both computed fields and new-API onchanges are automatically called by "
"the client without having to add them in views"
msgstr ""

#: ../../reference/orm.rst:465
msgid ""
"It is possible to suppress the trigger from a specific field by adding "
"``on_change=\"0\"`` in a view::"
msgstr ""

#: ../../reference/orm.rst:470
msgid ""
"will not trigger any interface update when the field is edited by the "
"user, even if there are function fields or explicit onchange depending on"
" that field."
msgstr ""

#: ../../reference/orm.rst:476
msgid ""
"``onchange`` methods work on virtual records assignment on these records "
"is not written to the database, just used to know which value to send "
"back to the client"
msgstr ""

#: ../../reference/orm.rst:481
msgid "Low-level SQL"
msgstr ""

#: ../../reference/orm.rst:483
msgid ""
"The :attr:`~odoo.api.Environment.cr` attribute on environments is the "
"cursor for the current database transaction and allows executing SQL "
"directly, either for queries which are difficult to express using the ORM"
" (e.g. complex joins) or for performance reasons::"
msgstr ""

#: ../../reference/orm.rst:490
msgid ""
"Because models use the same cursor and the :class:`~odoo.api.Environment`"
" holds various caches, these caches must be invalidated when *altering* "
"the database in raw SQL, or further uses of models may become incoherent."
" It is necessary to clear caches when using ``CREATE``, ``UPDATE`` or "
"``DELETE`` in SQL, but not ``SELECT`` (which simply reads the database)."
msgstr ""

#: ../../reference/orm.rst:496
msgid ""
"Clearing caches can be performed using the "
":meth:`~odoo.api.Environment.invalidate_all` method of the "
":class:`~odoo.api.Environment` object."
msgstr ""

#: ../../reference/orm.rst:504
msgid "Compatibility between new API and old API"
msgstr ""

#: ../../reference/orm.rst:506
msgid ""
"Odoo is currently transitioning from an older (less regular) API, it can "
"be necessary to manually bridge from one to the other manually:"
msgstr ""

#: ../../reference/orm.rst:509
msgid ""
"RPC layers (both XML-RPC and JSON-RPC) are expressed in terms of the old "
"API, methods expressed purely in the new API are not available over RPC"
msgstr ""

#: ../../reference/orm.rst:511
msgid ""
"overridable methods may be called from older pieces of code still written"
" in the old API style"
msgstr ""

#: ../../reference/orm.rst:514
msgid "The big differences between the old and new APIs are:"
msgstr ""

#: ../../reference/orm.rst:516
msgid ""
"values of the :class:`~odoo.api.Environment` (cursor, user id and "
"context) are passed explicitly to methods instead"
msgstr ""

#: ../../reference/orm.rst:518
msgid ""
"record data (:attr:`~odoo.models.Model.ids`) are passed explicitly to "
"methods, and possibly not passed at all"
msgstr ""

#: ../../reference/orm.rst:520
msgid "methods tend to work on lists of ids instead of recordsets"
msgstr ""

#: ../../reference/orm.rst:522
msgid ""
"By default, methods are assumed to use the new API style and are not "
"callable from the old API style."
msgstr ""

#: ../../reference/orm.rst:525
msgid "calls from the new API to the old API are bridged"
msgstr ""

#: ../../reference/orm.rst:528
msgid ""
"when using the new API style, calls to methods defined using the old API "
"are automatically converted on-the-fly, there should be no need to do "
"anything special::"
msgstr ""

#: ../../reference/orm.rst:545
msgid "Two decorators can expose a new-style method to the old API:"
msgstr ""

#: ../../reference/orm.rst:555
msgid ":func:`~odoo.api.model`"
msgstr ""

#: ../../reference/orm.rst:548
msgid ""
"the method is exposed as not using ids, its recordset will generally be "
"empty. Its \"old API\" signature is ``cr, uid, *arguments, context``::"
msgstr ""

#: ../../reference/orm.rst:565
msgid ":func:`~odoo.api.multi`"
msgstr ""

#: ../../reference/orm.rst:558
msgid ""
"the method is exposed as taking a list of ids (possibly empty), its \"old"
" API\" signature is ``cr, uid, ids, *arguments, context``::"
msgstr ""

#: ../../reference/orm.rst:567
msgid ""
"Because new-style APIs tend to return recordsets and old-style APIs tend "
"to return lists of ids, there is also a decorator managing this:"
msgstr ""

#: ../../reference/orm.rst:586
msgid ":func:`~odoo.api.returns`"
msgstr ""

#: ../../reference/orm.rst:571
msgid ""
"the function is assumed to return a recordset, the first parameter should"
" be the name of the recordset's model or ``self`` (for the current "
"model)."
msgstr ""

#: ../../reference/orm.rst:574
msgid ""
"No effect if the method is called in new API style, but transforms the "
"recordset into a list of ids when called from the old API style::"
msgstr ""

#: ../../reference/orm.rst:591
msgid "Model Reference"
msgstr ""

#: odoo.models.Model:1 of
msgid "Main super-class for regular database-persisted Odoo models."
msgstr ""

#: odoo.models.Model:3 of
msgid "Odoo models are created by inheriting from this class::"
msgstr ""

#: odoo.models.Model:8 of
msgid ""
"The system will later instantiate the class once per database (on which "
"the class' module is installed)."
msgstr ""

#: ../../reference/orm.rst:601
msgid "Structural attributes"
msgstr ""

#: ../../reference/orm.rst:604
msgid "business object name, in dot-notation (in module namespace)"
msgstr ""

#: ../../reference/orm.rst:608
msgid ""
"Alternative field to use as name, used by osvâ€™s name_get() (default: "
"``'name'``)"
msgstr ""

#: ../../reference/orm.rst:613
msgid ""
"If :attr:`._name` is set, names of parent models to inherit from. Can be "
"a ``str`` if inheriting from a single parent"
msgstr ""

#: ../../reference/orm.rst:615
msgid "If :attr:`._name` is unset, name of a single model to extend in-place"
msgstr ""

#: ../../reference/orm.rst:618
msgid "See :ref:`reference/orm/inheritance`."
msgstr ""

#: ../../reference/orm.rst:622
msgid ""
"Ordering field when searching without an ordering specified (default: "
"``'id'``)"
msgstr ""

#: ../../reference/orm.rst:625
msgid "str"
msgstr ""

#: ../../reference/orm.rst:629
msgid "Whether a database table should be created (default: ``True``)"
msgstr ""

#: ../../reference/orm.rst:631
msgid "If set to ``False``, override :meth:`.init` to create the database table"
msgstr ""

#: ../../reference/orm.rst:636
msgid ""
"Name of the table backing the model created when "
":attr:`~odoo.models.Model._auto`, automatically generated by default."
msgstr ""

#: ../../reference/orm.rst:642
msgid ""
"dictionary mapping the _name of the parent business objects to the names "
"of the corresponding foreign key fields to use::"
msgstr ""

#: ../../reference/orm.rst:650
msgid ""
"implements composition-based inheritance: the new model exposes all the "
"fields of the :attr:`~odoo.models.Model._inherits`-ed model but stores "
"none of them: the values themselves remain stored on the linked record."
msgstr ""

#: ../../reference/orm.rst:657
msgid ""
"if the same field is defined on multiple "
":attr:`~odoo.models.Model._inherits`-ed"
msgstr ""

#: ../../reference/orm.rst:662
msgid ""
"list of ``(constraint_function, message, fields)`` defining Python "
"constraints. The fields list is indicative"
msgstr ""

#: ../../reference/orm.rst:667
msgid "use :func:`~odoo.api.constrains`"
msgstr ""

#: ../../reference/orm.rst:671
msgid ""
"list of ``(name, sql_definition, message)`` triples defining SQL "
"constraints to execute when generating the backing table"
msgstr ""

#: ../../reference/orm.rst:676
msgid ""
"Alongside :attr:`~.parent_left` and :attr:`~.parent_right`, sets up a "
"`nested set <http://en.wikipedia.org/wiki/Nested_set_model>`_  to enable "
"fast hierarchical queries on the records of the current model (default: "
"``False``)"
msgstr ""

#: ../../reference/orm.rst:681
msgid "bool"
msgstr ""

#: ../../reference/orm.rst:684
msgid "CRUD"
msgstr ""

#: odoo.models.Model.create:1 of
msgid "Creates a new record for the model."
msgstr ""

#: odoo.models.Model.create:3 of
msgid ""
"The new record is initialized using the values from ``vals`` and if "
"necessary those from :meth:`~.default_get`."
msgstr ""

#: odoo.models.Model.create:6 of
msgid ""
"values for the model's fields, as a dictionary::      {'field_name': "
"field_value, ...}  see :meth:`~.write` for details"
msgstr ""

#: odoo.models.Model.create:7 of
msgid "values for the model's fields, as a dictionary::"
msgstr ""

#: odoo.models.Model.create:11 of
msgid "see :meth:`~.write` for details"
msgstr ""

#: odoo.models.Model.create:12 of
msgid "new record created"
msgstr ""

#: odoo.models.Model.create:13 of
msgid ""
"* if user has no create rights on the requested object * if user tries to"
" bypass access rules for create on the requested object"
msgstr ""

#: odoo.models.Model.create:13 of
msgid "if user has no create rights on the requested object"
msgstr ""

#: odoo.models.Model.create:14 of
msgid "if user tries to bypass access rules for create on the requested object"
msgstr ""

#: odoo.models.Model.create:15 odoo.models.Model.write:12 of
msgid "if user tries to enter invalid value for a field that is not in selection"
msgstr ""

#: odoo.models.Model.create:16 odoo.models.Model.write:13 of
msgid ""
"if a loop would be created in a hierarchy of objects a result of the "
"operation (such as setting an object as its own parent)"
msgstr ""

#: odoo.models.Model.browse:1 of
msgid ""
"Returns a recordset for the ids provided as parameter in the current "
"environment."
msgstr ""

#: odoo.models.Model.browse:4 of
msgid "Can take no ids, a single id or a sequence of ids."
msgstr ""

#: odoo.models.Model.unlink:1 of
msgid "Deletes the records of the current set"
msgstr ""

#: odoo.models.Model.unlink:3 of
msgid ""
"* if user has no unlink rights on the requested object * if user tries to"
" bypass access rules for unlink on the requested object"
msgstr ""

#: odoo.models.Model.unlink:3 of
msgid "if user has no unlink rights on the requested object"
msgstr ""

#: odoo.models.Model.unlink:4 of
msgid "if user tries to bypass access rules for unlink on the requested object"
msgstr ""

#: odoo.models.Model.unlink:5 of
msgid "if the record is default property for other records"
msgstr ""

#: odoo.models.Model.write:1 of
msgid "Updates all records in the current set with the provided values."
msgstr ""

#: odoo.models.Model.write:3 of
msgid ""
"fields to update and the value to set on them e.g::      {'foo': 1, "
"'bar': \"Qux\"}  will set the field ``foo`` to ``1`` and the field "
"``bar`` to ``\"Qux\"`` if those are valid (otherwise it will trigger an "
"error)."
msgstr ""

#: odoo.models.Model.write:3 of
msgid "fields to update and the value to set on them e.g::"
msgstr ""

#: odoo.models.Model.write:7 of
msgid ""
"will set the field ``foo`` to ``1`` and the field ``bar`` to ``\"Qux\"`` "
"if those are valid (otherwise it will trigger an error)."
msgstr ""

#: odoo.models.Model.write:10 of
msgid ""
"* if user has no write rights on the requested object * if user tries to "
"bypass access rules for write on the requested object"
msgstr ""

#: odoo.models.Model.write:10 of
msgid "if user has no write rights on the requested object"
msgstr ""

#: odoo.models.Model.write:11 of
msgid "if user tries to bypass access rules for write on the requested object"
msgstr ""

#: odoo.models.Model.write:15 of
msgid ""
"For numeric fields (:class:`~odoo.fields.Integer`, "
":class:`~odoo.fields.Float`) the value should be of the corresponding "
"type"
msgstr ""

#: odoo.models.Model.write:18 of
msgid ""
"For :class:`~odoo.fields.Boolean`, the value should be a "
":class:`python:bool`"
msgstr ""

#: odoo.models.Model.write:20 of
msgid ""
"For :class:`~odoo.fields.Selection`, the value should match the selection"
" values (generally :class:`python:str`, sometimes :class:`python:int`)"
msgstr ""

#: odoo.models.Model.write:23 of
msgid ""
"For :class:`~odoo.fields.Many2one`, the value should be the database "
"identifier of the record to set"
msgstr ""

#: odoo.models.Model.write:25 of
msgid "Other non-relational fields use a string for value"
msgstr ""

#: odoo.models.Model.write:29 of
msgid ""
"for historical and compatibility reasons, :class:`~odoo.fields.Date` and "
":class:`~odoo.fields.Datetime` fields use strings as values (written and "
"read) rather than :class:`~python:datetime.date` or "
":class:`~python:datetime.datetime`. These date strings are UTC-only and "
"formatted according to "
":const:`odoo.tools.misc.DEFAULT_SERVER_DATE_FORMAT` and "
":const:`odoo.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT`"
msgstr ""

#: odoo.models.Model.write:39 of
msgid ""
":class:`~odoo.fields.One2many` and :class:`~odoo.fields.Many2many` use a "
"special \"commands\" format to manipulate the set of records stored "
"in/associated with the field."
msgstr ""

#: odoo.models.Model.write:43 of
msgid ""
"This format is a list of triplets executed sequentially, where each "
"triplet is a command to execute on the set of records. Not all commands "
"apply in all situations. Possible commands are:"
msgstr ""

#: odoo.models.Model.write:47 of
msgid "``(0, _, values)``"
msgstr ""

#: odoo.models.Model.write:48 of
msgid "adds a new record created from the provided ``value`` dict."
msgstr ""

#: odoo.models.Model.write:50 of
msgid "``(1, id, values)``"
msgstr ""

#: odoo.models.Model.write:50 of
msgid ""
"updates an existing record of id ``id`` with the values in ``values``. "
"Can not be used in :meth:`~.create`."
msgstr ""

#: odoo.models.Model.write:53 of
msgid "``(2, id, _)``"
msgstr ""

#: odoo.models.Model.write:53 of
msgid ""
"removes the record of id ``id`` from the set, then deletes it (from the "
"database). Can not be used in :meth:`~.create`."
msgstr ""

#: odoo.models.Model.write:58 of
msgid "``(3, id, _)``"
msgstr ""

#: odoo.models.Model.write:56 of
msgid ""
"removes the record of id ``id`` from the set, but does not delete it. Can"
" not be used on :class:`~odoo.fields.One2many`. Can not be used in "
":meth:`~.create`."
msgstr ""

#: odoo.models.Model.write:61 of
msgid "``(4, id, _)``"
msgstr ""

#: odoo.models.Model.write:61 of
msgid ""
"adds an existing record of id ``id`` to the set. Can not be used on "
":class:`~odoo.fields.One2many`."
msgstr ""

#: odoo.models.Model.write:66 of
msgid "``(5, _, _)``"
msgstr ""

#: odoo.models.Model.write:64 of
msgid ""
"removes all records from the set, equivalent to using the command ``3`` "
"on every record explicitly. Can not be used on "
":class:`~odoo.fields.One2many`. Can not be used in :meth:`~.create`."
msgstr ""

#: odoo.models.Model.write:71 of
msgid "``(6, _, ids)``"
msgstr ""

#: odoo.models.Model.write:69 of
msgid ""
"replaces all existing records in the set by the ``ids`` list, equivalent "
"to using the command ``5`` followed by a command ``4`` for each ``id`` in"
" ``ids``."
msgstr ""

#: odoo.models.Model.write:73 of
msgid ""
"Values marked as ``_`` in the list above are ignored and can be anything,"
" generally ``0`` or ``False``."
msgstr ""

#: odoo.models.Model.read:1 of
msgid ""
"Reads the requested fields for the records in ``self``, low-level/RPC "
"method. In Python code, prefer :meth:`~.browse`."
msgstr ""

#: odoo.models.Model.read:4 of
msgid "list of field names to return (default is all fields)"
msgstr ""

#: odoo.models.Model.read:5 of
msgid ""
"a list of dictionaries mapping field names to their values, with one "
"dictionary per record"
msgstr ""

#: odoo.models.Model.read:7 of
msgid "if user has no read rights on some of the given records"
msgstr ""

#: odoo.models.Model.read_group:1 of
msgid ""
"Get the list of records in list view grouped by the given ``groupby`` "
"fields"
msgstr ""

#: odoo.models.Model.read_group:3 of
msgid "list specifying search criteria [['field_name', 'operator', 'value'], ...]"
msgstr ""

#: odoo.models.Model.read_group:4 of
msgid "list of fields present in the list view specified on the object"
msgstr ""

#: odoo.models.Model.read_group:5 of
msgid ""
"list of groupby descriptions by which the records will be grouped.   A "
"groupby description is either a field (then it will be grouped by that "
"field) or a string 'field:groupby_function'.  Right now, the only "
"functions supported are 'day', 'week', 'month', 'quarter' or 'year', and "
"they only make sense for  date/datetime fields."
msgstr ""

#: odoo.models.Model.read_group:10 of
msgid "optional number of records to skip"
msgstr ""

#: odoo.models.Model.name_search:18 odoo.models.Model.read_group:11 of
msgid "optional max number of records to return"
msgstr ""

#: odoo.models.Model.read_group:12 of
msgid ""
"optional ``order by`` specification, for overriding the natural sort "
"ordering of the groups, see also :py:meth:`~osv.osv.osv.search` "
"(supported only for many2one fields currently)"
msgstr ""

#: odoo.models.Model.read_group:16 of
msgid ""
"if true, the results are only grouped by the first groupby and the  "
"remaining groupbys are put in the __context key.  If false, all the "
"groupbys are done in one call."
msgstr ""

#: odoo.models.Model.read_group:19 of
msgid ""
"list of dictionaries(one dictionary for each record) containing:  * the "
"values of fields grouped by the fields in ``groupby`` argument * "
"__domain: list of tuples specifying the search criteria * __context: "
"dictionary with argument like ``groupby``"
msgstr ""

#: odoo.models.Model.read_group:19 of
msgid "list of dictionaries(one dictionary for each record) containing:"
msgstr ""

#: odoo.models.Model.read_group:21 of
msgid "the values of fields grouped by the fields in ``groupby`` argument"
msgstr ""

#: odoo.models.Model.read_group:22 of
msgid "__domain: list of tuples specifying the search criteria"
msgstr ""

#: odoo.models.Model.read_group:23 of
msgid "__context: dictionary with argument like ``groupby``"
msgstr ""

#: odoo.models.Model.read_group:25 of
msgid ""
"* if user has no read rights on the requested object * if user tries to "
"bypass access rules for read on the requested object"
msgstr ""

#: odoo.models.Model.read_group:25 of
msgid "if user has no read rights on the requested object"
msgstr ""

#: odoo.models.Model.read_group:26 of
msgid "if user tries to bypass access rules for read on the requested object"
msgstr ""

#: ../../reference/orm.rst:694
msgid "Searching"
msgstr ""

#: odoo.models.Model.search:1 of
msgid ""
"Searches for records based on the ``args`` :ref:`search domain "
"<reference/orm/domains>`."
msgstr ""

#: odoo.models.Model.search:4 of
msgid ""
":ref:`A search domain <reference/orm/domains>`. Use an empty list to "
"match all records."
msgstr ""

#: odoo.models.Model.search:6 of
msgid "number of results to ignore (default: none)"
msgstr ""

#: odoo.models.Model.search:7 of
msgid "maximum number of records to return (default: all)"
msgstr ""

#: odoo.models.Model.search:8 of
msgid "sort string"
msgstr ""

#: odoo.models.Model.search:9 of
msgid ""
"if True, only counts and returns the number of matching records (default:"
" False)"
msgstr ""

#: odoo.models.Model.search:10 of
msgid "at most ``limit`` records matching the search criteria"
msgstr ""

#: odoo.models.Model.search:12 of
msgid "* if user tries to bypass access rules for read on the requested object."
msgstr ""

#: odoo.models.Model.search:12 of
msgid "if user tries to bypass access rules for read on the requested object."
msgstr ""

#: odoo.models.Model.search_count:1 of
msgid ""
"Returns the number of records in the current model matching :ref:`the "
"provided domain <reference/orm/domains>`."
msgstr ""

#: odoo.models.Model.name_search:1 of
msgid ""
"Search for records that have a display name matching the given ``name`` "
"pattern when compared with the given ``operator``, while also matching "
"the optional search domain (``args``)."
msgstr ""

#: odoo.models.Model.name_search:5 of
msgid ""
"This is used for example to provide suggestions based on a partial value "
"for a relational field. Sometimes be seen as the inverse function of "
":meth:`~.name_get`, but it is not guaranteed to be."
msgstr ""

#: odoo.models.Model.name_search:9 of
msgid ""
"This method is equivalent to calling :meth:`~.search` with a search "
"domain based on ``display_name`` and then :meth:`~.name_get` on the "
"result of the search."
msgstr ""

#: odoo.models.Model.name_search:13 of
msgid "the name pattern to match"
msgstr ""

#: odoo.models.Model.name_search:14 of
msgid ""
"optional search domain (see :meth:`~.search` for syntax), specifying "
"further restrictions"
msgstr ""

#: odoo.models.Model.name_search:16 of
msgid "domain operator for matching ``name``, such as ``'like'`` or ``'='``."
msgstr ""

#: odoo.models.Model.name_search:20 of
msgid "list of pairs ``(id, text_repr)`` for all matching records."
msgstr ""

#: ../../reference/orm.rst:700
msgid "Recordset operations"
msgstr ""

#: odoo.models.Model.ids:1 of
msgid ""
"List of actual record ids in this recordset (ignores placeholder ids for "
"records to create)"
msgstr ""

#: odoo.models.Model.ensure_one:1 of
msgid ""
"Verifies that the current recorset holds a single record. Raises an "
"exception otherwise."
msgstr ""

#: odoo.models.Model.exists:1 of
msgid ""
"Returns the subset of records in ``self`` that exist, and marks deleted "
"records as such in cache. It can be used as a test on records::"
msgstr ""

#: odoo.models.Model.exists:7 of
msgid "By convention, new records are returned as existing."
msgstr ""

#: odoo.models.Model.filtered:1 of
msgid ""
"Select the records in ``self`` such that ``func(rec)`` is true, and "
"return them as a recordset."
msgstr ""

#: odoo.models.Model.filtered:4 of
msgid "a function or a dot-separated sequence of field names"
msgstr ""

#: odoo.models.Model.sorted:1 of
msgid "Return the recordset ``self`` ordered by ``key``."
msgstr ""

#: odoo.models.Model.sorted:3 of
msgid ""
"either a function of one argument that returns a comparison key for each "
"record, or a field name, or ``None``, in which case records are ordered "
"according the default model's order"
msgstr ""

#: odoo.models.Model.sorted:7 of
msgid "if ``True``, return the result in reverse order"
msgstr ""

#: odoo.models.Model.mapped:1 of
msgid ""
"Apply ``func`` on all records in ``self``, and return the result as a "
"list or a recordset (if ``func`` return recordsets). In the latter case, "
"the order of the returned recordset is arbitrary."
msgstr ""

#: odoo.models.Model.mapped:5 of
msgid ""
"a function or a dot-separated sequence of field names (string); any falsy"
" value simply returns the recordset ``self``"
msgstr ""

#: ../../reference/orm.rst:709
msgid "Environment swapping"
msgstr ""

#: odoo.models.Model.sudo:1 of
msgid "Returns a new version of this recordset attached to the provided user."
msgstr ""

#: odoo.models.Model.sudo:4 of
msgid ""
"By default this returns a ``SUPERUSER`` recordset, where access control "
"and record rules are bypassed."
msgstr ""

#: odoo.models.Model.sudo:9 of
msgid ""
"Using ``sudo`` could cause data access to cross the boundaries of record "
"rules, possibly mixing records that are meant to be isolated (e.g. "
"records from different companies in multi-company environments)."
msgstr ""

#: odoo.models.Model.sudo:14 of
msgid ""
"It may lead to un-intuitive results in methods which select one record "
"among many - for example getting the default company, or selecting a Bill"
" of Materials."
msgstr ""

#: odoo.models.Model.sudo:20 of
msgid ""
"Because the record rules and access control will have to be re-evaluated,"
" the new recordset will not benefit from the current environment's data "
"cache, so later data access may incur extra delays while re-fetching from"
" the database. The returned recordset has the same prefetch object as "
"``self``."
msgstr ""

#: odoo.models.Model.with_context:1 of
msgid "Returns a new version of this recordset attached to an extended context."
msgstr ""

#: odoo.models.Model.with_context:4 of
msgid ""
"The extended context is either the provided ``context`` in which "
"``overrides`` are merged or the *current* context in which ``overrides`` "
"are merged e.g.::"
msgstr ""

#: odoo.models.Model.with_env:1 of
msgid ""
"Returns a new version of this recordset attached to the provided "
"environment"
msgstr ""

#: odoo.models.Model.with_env:5 of
msgid ""
"The new environment will not benefit from the current environment's data "
"cache, so later data access may incur extra delays while re-fetching from"
" the database. The returned recordset has the same prefetch object as "
"``self``."
msgstr ""

#: ../../reference/orm.rst:715
msgid "Fields and views querying"
msgstr ""

#: odoo.models.Model.fields_get:1 of
msgid "Return the definition of each field."
msgstr ""

#: odoo.models.Model.fields_get:3 of
msgid ""
"The returned value is a dictionary (indiced by field name) of "
"dictionaries. The _inherits'd fields are included. The string, help, and "
"selection (if present) attributes are translated."
msgstr ""

#: odoo.models.Model.fields_get:7 of
msgid "list of fields to document, all if empty or not provided"
msgstr ""

#: odoo.models.Model.fields_get:8 of
msgid ""
"list of description attributes to return for each field, all if empty or "
"not provided"
msgstr ""

#: odoo.models.Model.fields_view_get:1 of
msgid ""
"Get the detailed composition of the requested view like fields, model, "
"view architecture"
msgstr ""

#: odoo.models.Model.fields_view_get:3 of
msgid "id of the view or None"
msgstr ""

#: odoo.models.Model.fields_view_get:4 of
msgid "type of the view to return if view_id is None ('form', 'tree', ...)"
msgstr ""

#: odoo.models.Model.fields_view_get:5 of
msgid "true to include contextual actions"
msgstr ""

#: odoo.models.Model.fields_view_get:6 of
msgid "deprecated"
msgstr ""

#: odoo.models.Model.fields_view_get:7 of
msgid ""
"dictionary describing the composition of the requested view (including "
"inherited views and extensions)"
msgstr ""

#: odoo.models.Model.fields_view_get:8 of
msgid ""
"* if the inherited view has unknown position to work with other than "
"'before', 'after', 'inside', 'replace' * if some tag other than "
"'position' is found in parent view"
msgstr ""

#: odoo.models.Model.fields_view_get:9 of
msgid ""
"if the inherited view has unknown position to work with other than "
"'before', 'after', 'inside', 'replace'"
msgstr ""

#: odoo.models.Model.fields_view_get:10 of
msgid "if some tag other than 'position' is found in parent view"
msgstr ""

#: odoo.models.Model.fields_view_get:11 of
msgid ""
"if there is view type other than form, tree, calendar, search etc defined"
" on the structure"
msgstr ""

#: ../../reference/orm.rst:720
msgid "Miscellaneous methods"
msgstr ""

#: odoo.models.Model.default_get:1 of
msgid ""
"Return default values for the fields in ``fields_list``. Default values "
"are determined by the context, user defaults, and the model itself."
msgstr ""

#: odoo.models.Model.default_get:5 of
msgid "a list of field names"
msgstr ""

#: odoo.models.Model.default_get:6 of
msgid ""
"a dictionary mapping each field name to its corresponding default value, "
"if it has one."
msgstr ""

#: odoo.models.Model.copy:1 of
msgid "Duplicate record ``self`` updating it with default values"
msgstr ""

#: odoo.models.Model.copy:3 of
msgid ""
"dictionary of field values to override in the original values of the "
"copied record, e.g: ``{'field_name': overridden_value, ...}``"
msgstr ""

#: odoo.models.Model.copy:5 of
msgid "new record"
msgstr ""

#: odoo.models.Model.name_get:1 of
msgid ""
"Returns a textual representation for the records in ``self``. By default "
"this is the value of the ``display_name`` field."
msgstr ""

#: odoo.models.Model.name_get:4 of
msgid "list of pairs ``(id, text_repr)`` for each records"
msgstr ""

#: odoo.models.Model.name_create:1 of
msgid ""
"Create a new record by calling :meth:`~.create` with only one value "
"provided: the display name of the new record."
msgstr ""

#: odoo.models.Model.name_create:4 of
msgid ""
"The new record will be initialized with any default values applicable to "
"this model, or provided through the context. The usual behavior of "
":meth:`~.create` applies."
msgstr ""

#: odoo.models.Model.name_create:8 of
msgid "display name of the record to create"
msgstr ""

#: odoo.models.Model.name_create:10 of
msgid "the :meth:`~.name_get` pair value of the created record"
msgstr ""

#: ../../reference/orm.rst:729
msgid "Automatic fields"
msgstr ""

#: ../../reference/orm.rst:732
msgid "Identifier :class:`field <odoo.fields.Field>`"
msgstr ""

#: ../../reference/orm.rst:736
msgid ""
"Whether log access fields (``create_date``, ``write_uid``, ...) should be"
" generated (default: ``True``)"
msgstr ""

#: ../../reference/orm.rst:741
msgid "Date at which the record was created"
msgstr ""

#: ../../reference/orm.rst:743 ../../reference/orm.rst:755
msgid ":class:`~odoo.field.Datetime`"
msgstr ""

#: ../../reference/orm.rst:747
msgid "Relational field to the user who created the record"
msgstr ""

#: ../../reference/orm.rst:749 ../../reference/orm.rst:761
msgid "``res.users``"
msgstr ""

#: ../../reference/orm.rst:753
msgid "Date at which the record was last modified"
msgstr ""

#: ../../reference/orm.rst:759
msgid "Relational field to the last user who modified the record"
msgstr ""

#: ../../reference/orm.rst:764
msgid "Reserved field names"
msgstr ""

#: ../../reference/orm.rst:765
msgid ""
"A few field names are reserved for pre-defined behaviors beyond that of "
"automated fields. They should be defined on a model when the related "
"behavior is desired:"
msgstr ""

#: ../../reference/orm.rst:771
msgid ""
"default value for :attr:`~._rec_name`, used to display records in context"
" where a representative \"naming\" is necessary."
msgstr ""

#: ../../reference/orm.rst:775
msgid ":class:`~odoo.fields.Char`"
msgstr ""

#: ../../reference/orm.rst:779
msgid ""
"toggles the global visibility of the record, if ``active`` is set to "
"``False`` the record is invisible in most searches and listing"
msgstr ""

#: ../../reference/orm.rst:782
msgid ":class:`~odoo.fields.Boolean`"
msgstr ""

#: ../../reference/orm.rst:786
msgid ""
"Alterable ordering criteria, allows drag-and-drop reordering of models in"
" list views"
msgstr ""

#: ../../reference/orm.rst:789
msgid ":class:`~odoo.fields.Integer`"
msgstr ""

#: ../../reference/orm.rst:793
msgid ""
"lifecycle stages of the object, used by the ``states`` attribute on "
":class:`fields <odoo.fields.Field>`"
msgstr ""

#: ../../reference/orm.rst:796
msgid ":class:`~odoo.fields.Selection`"
msgstr ""

#: ../../reference/orm.rst:800
msgid ""
"used to order records in a tree structure and enables the ``child_of`` "
"operator in domains"
msgstr ""

#: ../../reference/orm.rst:803
msgid ":class:`~odoo.fields.Many2one`"
msgstr ""

#: ../../reference/orm.rst:807
msgid "used with :attr:`~._parent_store`, allows faster tree structure access"
msgstr ""

#: ../../reference/orm.rst:811
msgid "see :attr:`~.parent_left`"
msgstr ""

#: ../../reference/orm.rst:816
msgid "Method decorators"
msgstr ""

#: odoo.api:1 of
msgid ""
"This module provides the elements for managing two different API styles, "
"namely the \"traditional\" and \"record\" styles."
msgstr ""

#: odoo.api:4 of
msgid ""
"In the \"traditional\" style, parameters like the database cursor, user "
"id, context dictionary and record ids (usually denoted as ``cr``, "
"``uid``, ``context``, ``ids``) are passed explicitly to all methods. In "
"the \"record\" style, those parameters are hidden into model instances, "
"which gives it a more object-oriented feel."
msgstr ""

#: odoo.api:10 of
msgid "For instance, the statements::"
msgstr ""

#: odoo.api:18 of
msgid "may also be written as::"
msgstr ""

#: odoo.api:27 of
msgid ""
"Methods written in the \"traditional\" style are automatically decorated,"
" following some heuristics based on parameter names."
msgstr ""

#: odoo.api.multi:1 of
msgid ""
"Decorate a record-style method where ``self`` is a recordset. The method "
"typically defines an operation on records. Such a method::"
msgstr ""

#: odoo.api.model:8 odoo.api.multi:8 odoo.api.one:11 of
msgid "may be called in both record and traditional styles, like::"
msgstr ""

#: odoo.api.model:1 of
msgid ""
"Decorate a record-style method where ``self`` is a recordset, but its "
"contents is not relevant, only the model is. Such a method::"
msgstr ""

#: odoo.api.model:15 of
msgid "Notice that no ``ids`` are passed to the method in the traditional style."
msgstr ""

#: odoo.api.depends:1 of
msgid ""
"Return a decorator that specifies the field dependencies of a \"compute\""
" method (for new-style function fields). Each argument must be a string "
"that consists in a dot-separated sequence of field names::"
msgstr ""

#: odoo.api.depends:15 of
msgid ""
"One may also pass a single function as argument. In that case, the "
"dependencies are given by calling the function with the field's model."
msgstr ""

#: odoo.api.constrains:1 of
msgid ""
"Decorates a constraint checker. Each argument must be a field name used "
"in the check::"
msgstr ""

#: odoo.api.constrains:10 of
msgid "Invoked on the records on which one of the named fields has been modified."
msgstr ""

#: odoo.api.constrains:12 of
msgid ""
"Should raise :class:`~odoo.exceptions.ValidationError` if the validation "
"failed."
msgstr ""

#: odoo.api.constrains:17 of
msgid ""
"``@constrains`` only supports simple field names, dotted names (fields of"
" relational fields e.g. ``partner_id.customer``) are not supported and "
"will be ignored"
msgstr ""

#: odoo.api.onchange:1 of
msgid ""
"Return a decorator to decorate an onchange method for given fields. Each "
"argument must be a field name::"
msgstr ""

#: odoo.api.onchange:8 of
msgid ""
"In the form views where the field appears, the method will be called when"
" one of the given fields is modified. The method is invoked on a pseudo-"
"record that contains the values present in the form. Field assignments on"
" that record are automatically sent back to the client."
msgstr ""

#: odoo.api.onchange:13 of
msgid ""
"The method may return a dictionary for changing field domains and pop up "
"a warning message, like in the old API::"
msgstr ""

#: odoo.api.onchange:24 of
msgid ""
"``@onchange`` only supports simple field names, dotted names (fields of "
"relational fields e.g. ``partner_id.tz``) are not supported and will be "
"ignored"
msgstr ""

#: odoo.api.returns:1 of
msgid "Return a decorator for methods that return instances of ``model``."
msgstr ""

#: odoo.api.returns:3 of
msgid "a model name, or ``'self'`` for the current model"
msgstr ""

#: odoo.api.returns:5 of
msgid ""
"a function ``downgrade(self, value, *args, **kwargs)`` to convert the "
"record-style ``value`` to a traditional-style output"
msgstr ""

#: odoo.api.returns:8 of
msgid ""
"a function ``upgrade(self, value, *args, **kwargs)`` to convert the "
"traditional-style ``value`` to a record-style output"
msgstr ""

#: odoo.api.returns:11 of
msgid ""
"The arguments ``self``, ``*args`` and ``**kwargs`` are the ones passed to"
" the method in the record-style."
msgstr ""

#: odoo.api.returns:14 of
msgid ""
"The decorator adapts the method output to the api style: ``id``, ``ids`` "
"or ``False`` for the traditional style, and recordset for the record "
"style::"
msgstr ""

#: odoo.api.returns:28 of
msgid "Note that the decorated method must satisfy that convention."
msgstr ""

#: odoo.api.returns:30 of
msgid ""
"Those decorators are automatically *inherited*: a method that overrides a"
" decorated existing method will be decorated with the same "
"``@returns(model)``."
msgstr ""

#: odoo.api.one:1 of
msgid ""
"Decorate a record-style method where ``self`` is expected to be a "
"singleton instance. The decorated method automatically loops on records, "
"and makes a list with the results. In case the method is decorated with "
":func:`returns`, it concatenates the resulting instances. Such a method::"
msgstr ""

#: odoo.api.one:20 of
msgid ""
":func:`~.one` often makes the code less clear and behaves in ways "
"developers and readers may not expect."
msgstr ""

#: odoo.api.one:23 of
msgid ""
"It is strongly recommended to use :func:`~.multi` and either iterate on "
"the ``self`` recordset or ensure that the recordset is a single record "
"with :meth:`~odoo.models.Model.ensure_one`."
msgstr ""

#: odoo.api.v7:1 of
msgid ""
"Decorate a method that supports the old-style api only. A new-style api "
"may be provided by redefining a method with the same name and decorated "
"with :func:`~.v8`::"
msgstr ""

#: odoo.api.v7:13 of
msgid ""
"Special care must be taken if one method calls the other one, because the"
" method may be overridden! In that case, one should call the method from "
"the current class (say ``MyClass``), for instance::"
msgstr ""

#: odoo.api.v7:23 odoo.api.v8:13 of
msgid "Note that the wrapper method uses the docstring of the first method."
msgstr ""

#: odoo.api.v8:1 of
msgid ""
"Decorate a method that supports the new-style api only. An old-style api "
"may be provided by redefining a method with the same name and decorated "
"with :func:`~.v7`::"
msgstr ""

#: ../../reference/orm.rst:825
msgid "Fields"
msgstr ""

#: ../../reference/orm.rst:830
msgid "Basic fields"
msgstr ""

#: odoo.fields.Field:1 of
msgid ""
"The field descriptor contains the field definition, and manages accesses "
"and assignments of the corresponding field on records. The following "
"attributes may be provided when instanciating a field:"
msgstr ""

#: odoo.fields.Field:5 of
msgid ""
"the label of the field seen by users (string); if not set, the ORM takes "
"the field name in the class (capitalized)."
msgstr ""

#: odoo.fields.Field:8 of
msgid "the tooltip of the field seen by users (string)"
msgstr ""

#: odoo.fields.Field:10 of
msgid "whether the field is readonly (boolean, by default ``False``)"
msgstr ""

#: odoo.fields.Field:12 of
msgid "whether the value of the field is required (boolean, by default ``False``)"
msgstr ""

#: odoo.fields.Field:15 of
msgid "whether the field is indexed in database (boolean, by default ``False``)"
msgstr ""

#: odoo.fields.Field:18 of
msgid ""
"the default value for the field; this is either a static value, or a "
"function taking a recordset and returning a value; use ``default=None`` "
"to discard default values for the field"
msgstr ""

#: odoo.fields.Field:22 of
msgid ""
"a dictionary mapping state values to lists of UI attribute-value pairs; "
"possible attributes are: 'readonly', 'required', 'invisible'. Note: Any "
"state-based condition requires the ``state`` field value to be available "
"on the client-side UI. This is typically done by including it in the "
"relevant views, possibly made invisible if not relevant for the end-user."
msgstr ""

#: odoo.fields.Field:29 of
msgid ""
"comma-separated list of group xml ids (string); this restricts the field "
"access to the users of the given groups only"
msgstr ""

#: odoo.fields.Field:32 of
msgid ""
"whether the field value should be copied when the record is duplicated "
"(default: ``True`` for normal fields, ``False`` for ``one2many`` and "
"computed fields, including property fields and related fields)"
msgstr ""

#: odoo.fields.Field:37 of
msgid ""
"the previous name of this field, so that ORM can rename it automatically "
"at migration"
msgstr ""

#: odoo.fields.Field:44 of
msgid ""
"One can define a field whose value is computed instead of simply being "
"read from the database. The attributes that are specific to computed "
"fields are given below. To define such a field, simply provide a value "
"for the attribute ``compute``."
msgstr ""

#: odoo.fields.Field:49 of
msgid "name of a method that computes the field"
msgstr ""

#: odoo.fields.Field:51 of
msgid "name of a method that inverses the field (optional)"
msgstr ""

#: odoo.fields.Field:53 of
msgid "name of a method that implement search on the field (optional)"
msgstr ""

#: odoo.fields.Field:55 of
msgid ""
"whether the field is stored in database (boolean, by default ``False`` on"
" computed fields)"
msgstr ""

#: odoo.fields.Field:58 of
msgid ""
"whether the field should be recomputed as superuser to bypass access "
"rights (boolean, by default ``False``)"
msgstr ""

#: odoo.fields.Field:61 of
msgid ""
"The methods given for ``compute``, ``inverse`` and ``search`` are model "
"methods. Their signature is shown in the following example::"
msgstr ""

#: odoo.fields.Field:82 of
msgid ""
"The compute method has to assign the field on all records of the invoked "
"recordset. The decorator :meth:`odoo.api.depends` must be applied on the "
"compute method to specify the field dependencies; those dependencies are "
"used to determine when to recompute the field; recomputation is automatic"
" and guarantees cache/database consistency. Note that the same method can"
" be used for several fields, you simply have to assign all the given "
"fields in the method; the method will be invoked once for all those "
"fields."
msgstr ""

#: odoo.fields.Field:91 of
msgid ""
"By default, a computed field is not stored to the database, and is "
"computed on-the-fly. Adding the attribute ``store=True`` will store the "
"field's values in the database. The advantage of a stored field is that "
"searching on that field is done by the database itself. The disadvantage "
"is that it requires database updates when the field must be recomputed."
msgstr ""

#: odoo.fields.Field:97 of
msgid ""
"The inverse method, as its name says, does the inverse of the compute "
"method: the invoked records have a value for the field, and you must "
"apply the necessary changes on the field dependencies such that the "
"computation gives the expected value. Note that a computed field without "
"an inverse method is readonly by default."
msgstr ""

#: odoo.fields.Field:103 of
msgid ""
"The search method is invoked when processing domains before doing an "
"actual search on the model. It must return a domain equivalent to the "
"condition: ``field operator value``."
msgstr ""

#: odoo.fields.Field:111 of
msgid ""
"The value of a related field is given by following a sequence of "
"relational fields and reading a field on the reached model. The complete "
"sequence of fields to traverse is specified by the attribute"
msgstr ""

#: odoo.fields.Field:115 of
msgid "sequence of field names"
msgstr ""

#: odoo.fields.Field:117 of
msgid ""
"Some field attributes are automatically copied from the source field if "
"they are not redefined: ``string``, ``help``, ``readonly``, ``required`` "
"(only if all fields in the sequence are required), ``groups``, "
"``digits``, ``size``, ``translate``, ``sanitize``, ``selection``, "
"``comodel_name``, ``domain``, ``context``. All semantic-free attributes "
"are copied from the source field."
msgstr ""

#: odoo.fields.Field:124 of
msgid ""
"By default, the values of related fields are not stored to the database. "
"Add the attribute ``store=True`` to make it stored, just like computed "
"fields. Related fields are automatically recomputed when their "
"dependencies are modified."
msgstr ""

#: odoo.fields.Field:132 of
msgid "Company-dependent fields"
msgstr ""

#: odoo.fields.Field:133 of
msgid ""
"Formerly known as 'property' fields, the value of those fields depends on"
" the company. In other words, users that belong to different companies "
"may see different values for the field on a given record."
msgstr ""

#: odoo.fields.Field:137 of
msgid "whether the field is company-dependent (boolean)"
msgstr ""

#: odoo.fields.Field:142 of
msgid "Incremental definition"
msgstr ""

#: odoo.fields.Field:143 of
msgid ""
"A field is defined as class attribute on a model class. If the model is "
"extended (see :class:`~odoo.models.Model`), one can also extend the field"
" definition by redefining a field with the same name and same type on the"
" subclass. In that case, the attributes of the field are taken from the "
"parent class and overridden by the ones given in subclasses."
msgstr ""

#: odoo.fields.Field:150 of
msgid ""
"For instance, the second class below only adds a tooltip on the field "
"``state``::"
msgstr ""

#: odoo.fields.Char:1 odoo.fields.Html:1 odoo.fields.Text:1 of
msgid "Bases: :class:`odoo.fields._String`"
msgstr ""

#: odoo.fields.Char:1 of
msgid ""
"Basic string field, can be length-limited, usually displayed as a single-"
"line string in clients."
msgstr ""

#: odoo.fields.Char:4 of
msgid "the maximum size of values stored for that field"
msgstr ""

#: odoo.fields.Char:6 odoo.fields.Text:4 of
msgid ""
"enable the translation of the field's values; use ``translate=True`` to "
"translate field values as a whole; ``translate`` may also be a callable "
"such that ``translate(callback, value)`` translates ``value`` by using "
"``callback(term)`` to retrieve the translation of terms."
msgstr ""

#: odoo.fields.Boolean:1 odoo.fields.Date:1 odoo.fields.Datetime:1
#: odoo.fields.Float:1 odoo.fields.Integer:1 odoo.fields.Selection:1 of
msgid "Bases: :class:`odoo.fields.Field`"
msgstr ""

#: odoo.fields.Float:1 of
msgid "The precision digits are given by the attribute"
msgstr ""

#: odoo.fields.Float:3 of
msgid ""
"a pair (total, decimal), or a function taking a database cursor and "
"returning a pair (total, decimal)"
msgstr ""

#: odoo.fields.Text:1 of
msgid ""
"Very similar to :class:`~.Char` but used for longer contents, does not "
"have a size and usually displayed as a multiline text box."
msgstr ""

#: odoo.fields.Selection:1 of
msgid ""
"specifies the possible values for this field. It is given as either a "
"list of pairs (``value``, ``string``), or a model method, or a method "
"name."
msgstr ""

#: odoo.fields.Selection:4 of
msgid ""
"provides an extension of the selection in the case of an overridden "
"field. It is a list of pairs (``value``, ``string``)."
msgstr ""

#: odoo.fields.Selection:7 of
msgid ""
"The attribute ``selection`` is mandatory except in the case of "
":ref:`related fields <field-related>` or :ref:`field extensions <field-"
"incremental-definition>`."
msgstr ""

#: odoo.fields.Date.context_today:1 of
msgid ""
"Return the current date as seen in the client's timezone in a format fit "
"for date fields. This method may be used to compute default values."
msgstr ""

#: odoo.fields.Date.context_today:5 of
msgid ""
"optional datetime value to use instead of the current date and time (must"
" be a datetime, regular dates can't be converted between timezones.)"
msgstr ""

#: odoo.fields.Date.from_string:1 of
msgid "Convert an ORM ``value`` into a :class:`date` value."
msgstr ""

#: odoo.fields.Date.to_string:1 of
msgid "Convert a :class:`date` value into the format expected by the ORM."
msgstr ""

#: odoo.fields.Date.today:1 of
msgid ""
"Return the current day in the format expected by the ORM. This function "
"may be used to compute default values."
msgstr ""

#: odoo.fields.Datetime.context_timestamp:1 of
msgid ""
"Returns the given timestamp converted to the client's timezone. This "
"method is *not* meant for use as a default initializer, because datetime "
"fields are automatically converted upon display on client side. For "
"default values :meth:`fields.datetime.now` should be used instead."
msgstr ""

#: odoo.fields.Datetime.context_timestamp:7 of
msgid ""
"naive datetime value (expressed in UTC) to be converted to the client "
"timezone"
msgstr ""

#: odoo.fields.Datetime.context_timestamp:10 of
msgid "timestamp converted to timezone-aware datetime in context timezone"
msgstr ""

#: odoo.fields.Datetime.from_string:1 of
msgid "Convert an ORM ``value`` into a :class:`datetime` value."
msgstr ""

#: odoo.fields.Datetime.now:1 of
msgid ""
"Return the current day and time in the format expected by the ORM. This "
"function may be used to compute default values."
msgstr ""

#: odoo.fields.Datetime.to_string:1 of
msgid "Convert a :class:`datetime` value into the format expected by the ORM."
msgstr ""

#: ../../reference/orm.rst:872
msgid "Relational fields"
msgstr ""

#: odoo.fields.Many2one:1 of
msgid "Bases: :class:`odoo.fields._Relational`"
msgstr ""

#: odoo.fields.Many2one:1 of
msgid ""
"The value of such a field is a recordset of size 0 (no record) or 1 (a "
"single record)."
msgstr ""

#: odoo.fields.Many2many:3 odoo.fields.Many2one:4 odoo.fields.One2many:5 of
msgid "name of the target model (string)"
msgstr ""

#: odoo.fields.Many2many:21 odoo.fields.Many2one:6 odoo.fields.One2many:10 of
msgid ""
"an optional domain to set on candidate values on the client side (domain "
"or string)"
msgstr ""

#: odoo.fields.Many2many:24 odoo.fields.Many2one:9 odoo.fields.One2many:13 of
msgid ""
"an optional context to use on the client side when handling that field "
"(dictionary)"
msgstr ""

#: odoo.fields.Many2one:12 of
msgid ""
"what to do when the referred record is deleted; possible values are: "
"``'set null'``, ``'restrict'``, ``'cascade'``"
msgstr ""

#: odoo.fields.Many2one:15 odoo.fields.One2many:16 of
msgid ""
"whether JOINs are generated upon search through that field (boolean, by "
"default ``False``)"
msgstr ""

#: odoo.fields.Many2one:18 of
msgid ""
"set it to ``True`` to make fields of the target model accessible from the"
" current model (corresponds to ``_inherits``)"
msgstr ""

#: odoo.fields.Many2many:5 odoo.fields.Many2one:21 of
msgid ""
"The attribute ``comodel_name`` is mandatory except in the case of related"
" fields or field extensions."
msgstr ""

#: odoo.fields.Many2many:1 odoo.fields.One2many:1 of
msgid "Bases: :class:`odoo.fields._RelationalMulti`"
msgstr ""

#: odoo.fields.One2many:1 of
msgid ""
"One2many field; the value of such a field is the recordset of all the "
"records in ``comodel_name`` such that the field ``inverse_name`` is equal"
" to the current record."
msgstr ""

#: odoo.fields.One2many:7 of
msgid "name of the inverse ``Many2one`` field in ``comodel_name`` (string)"
msgstr ""

#: odoo.fields.Many2many:27 odoo.fields.One2many:19 of
msgid "optional limit to use upon read (integer)"
msgstr ""

#: odoo.fields.One2many:21 of
msgid ""
"The attributes ``comodel_name`` and ``inverse_name`` are mandatory except"
" in the case of related fields or field extensions."
msgstr ""

#: odoo.fields.Many2many:1 of
msgid "Many2many field; the value of such a field is the recordset."
msgstr ""

#: odoo.fields.Many2many:8 of
msgid ""
"optional name of the table that stores the relation in the database "
"(string)"
msgstr ""

#: odoo.fields.Many2many:11 of
msgid ""
"optional name of the column referring to \"these\" records in the table "
"``relation`` (string)"
msgstr ""

#: odoo.fields.Many2many:14 of
msgid ""
"optional name of the column referring to \"those\" records in the table "
"``relation`` (string)"
msgstr ""

#: odoo.fields.Many2many:17 of
msgid ""
"The attributes ``relation``, ``column1`` and ``column2`` are optional. If"
" not given, names are automatically generated from model names, provided "
"``model_name`` and ``comodel_name`` are different!"
msgstr ""

#: odoo.fields.Reference:1 of
msgid "Bases: :class:`odoo.fields.Selection`"
msgstr ""

#: ../../reference/orm.rst:889
msgid "Inheritance and extension"
msgstr ""

#: ../../reference/orm.rst:891
msgid ""
"Odoo provides three different mechanisms to extend models in a modular "
"way:"
msgstr ""

#: ../../reference/orm.rst:893
msgid ""
"creating a new model from an existing one, adding new information to the "
"copy but leaving the original module as-is"
msgstr ""

#: ../../reference/orm.rst:895
msgid ""
"extending models defined in other modules in-place, replacing the "
"previous version"
msgstr ""

#: ../../reference/orm.rst:897
msgid "delegating some of the model's fields to records it contains"
msgstr ""

#: ../../reference/orm.rst:903
msgid "Classical inheritance"
msgstr ""

#: ../../reference/orm.rst:905
msgid ""
"When using the :attr:`~odoo.models.Model._inherit` and "
":attr:`~odoo.models.Model._name` attributes together, Odoo creates a new "
"model using the existing one (provided via "
":attr:`~odoo.models.Model._inherit`) as a base. The new model gets all "
"the fields, methods and meta-information (defaults & al) from its base."
msgstr ""

#: ../../reference/orm.rst:915
msgid "and using them:"
msgstr ""

#: ../../reference/orm.rst:921 ../../reference/orm.rst:948
msgid "will yield:"
msgstr ""

#: ../../reference/orm.rst:927
msgid ""
"the second model has inherited from the first model's ``check`` method "
"and its ``name`` field, but overridden the ``call`` method, as when using"
" standard :ref:`Python inheritance <python:tut-inheritance>`."
msgstr ""

#: ../../reference/orm.rst:932
msgid "Extension"
msgstr ""

#: ../../reference/orm.rst:934
msgid ""
"When using :attr:`~odoo.models.Model._inherit` but leaving out "
":attr:`~odoo.models.Model._name`, the new model replaces the existing "
"one, essentially extending it in-place. This is useful to add new fields "
"or methods to existing models (created in other modules), or to customize"
" or reconfigure them (e.g. to change their default sort order):"
msgstr ""

#: ../../reference/orm.rst:954
msgid ""
"it will also yield the various :ref:`automatic fields "
"<reference/orm/model/automatic>` unless they've been disabled"
msgstr ""

#: ../../reference/orm.rst:958
msgid "Delegation"
msgstr ""

#: ../../reference/orm.rst:960
msgid ""
"The third inheritance mechanism provides more flexibility (it can be "
"altered at runtime) but less power: using the "
":attr:`~odoo.models.Model._inherits` a model *delegates* the lookup of "
"any field not found on the current model to \"children\" models. The "
"delegation is performed via :class:`~odoo.fields.Reference` fields "
"automatically set up on the parent model:"
msgstr ""

#: ../../reference/orm.rst:975
msgid "will result in:"
msgstr ""

#: ../../reference/orm.rst:981
msgid "and it's possible to write directly on the delegated field:"
msgstr ""

#: ../../reference/orm.rst:987
msgid ""
"when using delegation inheritance, methods are *not* inherited, only "
"fields"
msgstr ""

#: ../../reference/orm.rst:993
msgid "Domains"
msgstr ""

#: ../../reference/orm.rst:995
msgid ""
"A domain is a list of criteria, each criterion being a triple (either a "
"``list`` or a ``tuple``) of ``(field_name, operator, value)`` where:"
msgstr ""

#: ../../reference/orm.rst:1000
msgid "``field_name`` (``str``)"
msgstr ""

#: ../../reference/orm.rst:999
msgid ""
"a field name of the current model, or a relationship traversal through a "
":class:`~odoo.fields.Many2one` using dot-notation e.g. ``'street'`` or "
"``'partner_id.country'``"
msgstr ""

#: ../../reference/orm.rst:1046
msgid "``operator`` (``str``)"
msgstr ""

#: ../../reference/orm.rst:1003
msgid ""
"an operator used to compare the ``field_name`` with the ``value``. Valid "
"operators are:"
msgstr ""

#: ../../reference/orm.rst:1006
msgid "``=``"
msgstr ""

#: ../../reference/orm.rst:1007
msgid "equals to"
msgstr ""

#: ../../reference/orm.rst:1008
msgid "``!=``"
msgstr ""

#: ../../reference/orm.rst:1009
msgid "not equals to"
msgstr ""

#: ../../reference/orm.rst:1010
msgid "``>``"
msgstr ""

#: ../../reference/orm.rst:1011
msgid "greater than"
msgstr ""

#: ../../reference/orm.rst:1012
msgid "``>=``"
msgstr ""

#: ../../reference/orm.rst:1013
msgid "greater than or equal to"
msgstr ""

#: ../../reference/orm.rst:1014
msgid "``<``"
msgstr ""

#: ../../reference/orm.rst:1015
msgid "less than"
msgstr ""

#: ../../reference/orm.rst:1016
msgid "``<=``"
msgstr ""

#: ../../reference/orm.rst:1017
msgid "less than or equal to"
msgstr ""

#: ../../reference/orm.rst:1019
msgid "``=?``"
msgstr ""

#: ../../reference/orm.rst:1019
msgid ""
"unset or equals to (returns true if ``value`` is either ``None`` or "
"``False``, otherwise behaves like ``=``)"
msgstr ""

#: ../../reference/orm.rst:1023
msgid "``=like``"
msgstr ""

#: ../../reference/orm.rst:1022
msgid ""
"matches ``field_name`` against the ``value`` pattern. An underscore ``_``"
" in the pattern stands for (matches) any single character; a percent sign"
" ``%`` matches any string of zero or more characters."
msgstr ""

#: ../../reference/orm.rst:1026
msgid "``like``"
msgstr ""

#: ../../reference/orm.rst:1026
msgid ""
"matches ``field_name`` against the ``%value%`` pattern. Similar to "
"``=like`` but wraps ``value`` with '%' before matching"
msgstr ""

#: ../../reference/orm.rst:1028
msgid "``not like``"
msgstr ""

#: ../../reference/orm.rst:1029
msgid "doesn't match against the ``%value%`` pattern"
msgstr ""

#: ../../reference/orm.rst:1030
msgid "``ilike``"
msgstr ""

#: ../../reference/orm.rst:1031
msgid "case insensitive ``like``"
msgstr ""

#: ../../reference/orm.rst:1032
msgid "``not ilike``"
msgstr ""

#: ../../reference/orm.rst:1033
msgid "case insensitive ``not like``"
msgstr ""

#: ../../reference/orm.rst:1034
msgid "``=ilike``"
msgstr ""

#: ../../reference/orm.rst:1035
msgid "case insensitive ``=like``"
msgstr ""

#: ../../reference/orm.rst:1037
msgid "``in``"
msgstr ""

#: ../../reference/orm.rst:1037
msgid ""
"is equal to any of the items from ``value``, ``value`` should be a list "
"of items"
msgstr ""

#: ../../reference/orm.rst:1039
msgid "``not in``"
msgstr ""

#: ../../reference/orm.rst:1040
msgid "is unequal to all of the items from ``value``"
msgstr ""

#: ../../reference/orm.rst:1046
msgid "``child_of``"
msgstr ""

#: ../../reference/orm.rst:1042
msgid "is a child (descendant) of a ``value`` record."
msgstr ""

#: ../../reference/orm.rst:1044
msgid ""
"Takes the semantics of the model into account (i.e following the "
"relationship field named by :attr:`~odoo.models.Model._parent_name`)."
msgstr ""

#: ../../reference/orm.rst:1050
msgid "``value``"
msgstr ""

#: ../../reference/orm.rst:1049
msgid ""
"variable type, must be comparable (through ``operator``) to the named "
"field"
msgstr ""

#: ../../reference/orm.rst:1052
msgid "Domain criteria can be combined using logical operators in *prefix* form:"
msgstr ""

#: ../../reference/orm.rst:1055
msgid "``'&'``"
msgstr ""

#: ../../reference/orm.rst:1055
msgid ""
"logical *AND*, default operation to combine criteria following one "
"another. Arity 2 (uses the next 2 criteria or combinations)."
msgstr ""

#: ../../reference/orm.rst:1057
msgid "``'|'``"
msgstr ""

#: ../../reference/orm.rst:1058
msgid "logical *OR*, arity 2."
msgstr ""

#: ../../reference/orm.rst:1066
msgid "``'!'``"
msgstr ""

#: ../../reference/orm.rst:1060
msgid "logical *NOT*, arity 1."
msgstr ""

#: ../../reference/orm.rst:1062
msgid "Mostly to negate combinations of criteria"
msgstr ""

#: ../../reference/orm.rst:1065
msgid ""
"Individual criterion generally have a negative form (e.g. ``=`` -> "
"``!=``, ``<`` -> ``>=``) which is simpler than negating the positive."
msgstr ""

#: ../../reference/orm.rst:1068
msgid "Example"
msgstr ""

#: ../../reference/orm.rst:1070
msgid ""
"To search for partners named *ABC*, from belgium or germany, whose "
"language is not english::"
msgstr ""

#: ../../reference/orm.rst:1078
msgid "This domain is interpreted as:"
msgstr ""

#: ../../reference/orm.rst:1087
msgid "Porting from the old API to the new API"
msgstr ""

#: ../../reference/orm.rst:1089
msgid "bare lists of ids are to be avoided in the new API, use recordsets instead"
msgstr ""

#: ../../reference/orm.rst:1090
msgid ""
"methods still written in the old API should be automatically bridged by "
"the ORM, no need to switch to the old API, just call them as if they were"
" a new API method. See :ref:`reference/orm/oldapi/bridging` for more "
"details."
msgstr ""

#: ../../reference/orm.rst:1093
msgid ""
":meth:`~odoo.models.Model.search` returns a recordset, no point in e.g. "
"browsing its result"
msgstr ""

#: ../../reference/orm.rst:1095
msgid ""
"``fields.related`` and ``fields.function`` are replaced by using a normal"
" field type with either a ``related=`` or a ``compute=`` parameter"
msgstr ""

#: ../../reference/orm.rst:1097
msgid ""
":func:`~odoo.api.depends` on ``compute=`` methods **must be complete**, "
"it must list **all** the fields and sub-fields which the compute method "
"uses. It is better to have too many dependencies (will recompute the "
"field in cases where that is not needed) than not enough (will forget to "
"recompute the field and then values will be incorrect)"
msgstr ""

#: ../../reference/orm.rst:1102
msgid ""
"**remove** all ``onchange`` methods on computed fields. Computed fields "
"are automatically re-computed when one of their dependencies is changed, "
"and that is used to auto-generate ``onchange`` by the client"
msgstr ""

#: ../../reference/orm.rst:1105
msgid ""
"the decorators :func:`~odoo.api.model` and :func:`~odoo.api.multi` are "
"for bridging *when calling from the old API context*, for internal or "
"pure new-api (e.g. compute) they are useless"
msgstr ""

#: ../../reference/orm.rst:1108
msgid ""
"remove :attr:`~odoo.models.Model._default`, replace by ``default=`` "
"parameter on corresponding fields"
msgstr ""

#: ../../reference/orm.rst:1110
msgid "if a field's ``string=`` is the titlecased version of the field name::"
msgstr ""

#: ../../reference/orm.rst:1114
msgid "it is useless and should be removed"
msgstr ""

#: ../../reference/orm.rst:1115
msgid ""
"the ``multi=`` parameter does not do anything on new API fields use the "
"same ``compute=`` methods on all relevant fields for the same result"
msgstr ""

#: ../../reference/orm.rst:1117
msgid ""
"provide ``compute=``, ``inverse=`` and ``search=`` methods by name (as a "
"string), this makes them overridable (removes the need for an "
"intermediate \"trampoline\" function)"
msgstr ""

#: ../../reference/orm.rst:1120
msgid ""
"double check that all fields and methods have different names, there is "
"no warning in case of collision (because Python handles it before Odoo "
"sees anything)"
msgstr ""

#: ../../reference/orm.rst:1123
msgid ""
"the normal new-api import is ``from odoo import fields, models``. If "
"compatibility decorators are necessary, use ``from odoo import api, "
"fields, models``"
msgstr ""

#: ../../reference/orm.rst:1126
msgid ""
"avoid the :func:`~odoo.api.one` decorator, it probably does not do what "
"you expect"
msgstr ""

#: ../../reference/orm.rst:1128
msgid ""
"remove explicit definition of :attr:`~odoo.models.Model.create_uid`, "
":attr:`~odoo.models.Model.create_date`, "
":attr:`~odoo.models.Model.write_uid` and "
":attr:`~odoo.models.Model.write_date` fields: they are now created as "
"regular \"legitimate\" fields, and can be read and written like any other"
" field out-of-the-box"
msgstr ""

#: ../../reference/orm.rst:1134
msgid ""
"when straight conversion is impossible (semantics can not be bridged) or "
"the \"old API\" version is not desirable and could be improved for the "
"new API, it is possible to use completely different \"old API\" and \"new"
" API\" implementations for the same method name using "
":func:`~odoo.api.v7` and :func:`~odoo.api.v8`. The method should first be"
" defined using the old-API style and decorated with :func:`~odoo.api.v7`,"
" it should then be re-defined using the exact same name but the new-API "
"style and decorated with :func:`~odoo.api.v8`. Calls from an old-API "
"context will be dispatched to the first implementation and calls from a "
"new-API context will be dispatched to the second implementation. One "
"implementation can call (and frequently does) call the other by switching"
" context."
msgstr ""

#: ../../reference/orm.rst:1146
msgid ""
"using these decorators makes methods extremely difficult to override and "
"harder to understand and document"
msgstr ""

#: ../../reference/orm.rst:1148
msgid ""
"uses of :attr:`~odoo.models.Model._columns` or "
":attr:`~odoo.models.Model._all_columns` should be replaced by "
":attr:`~odoo.models.Model._fields`, which provides access to instances of"
" new-style :class:`odoo.fields.Field` instances (rather than old-style "
":class:`odoo.osv.fields._column`)."
msgstr ""

#: ../../reference/orm.rst:1154
msgid ""
"Non-stored computed fields created using the new API style are *not* "
"available in :attr:`~odoo.models.Model._columns` and can only be "
"inspected through :attr:`~odoo.models.Model._fields`"
msgstr ""

#: ../../reference/orm.rst:1157
msgid ""
"reassigning ``self`` in a method is probably unnecessary and may break "
"translation introspection"
msgstr ""

#: ../../reference/orm.rst:1159
msgid ""
":class:`~odoo.api.Environment` objects rely on some threadlocal state, "
"which has to be set up before using them. It is necessary to do so using "
"the :meth:`odoo.api.Environment.manage` context manager when trying to "
"use the new API in contexts where it hasn't been set up yet, such as new "
"threads or a Python interactive environment::"
msgstr ""

#: ../../reference/orm.rst:1181
msgid "Automatic bridging of old API methods"
msgstr ""

#: ../../reference/orm.rst:1183
msgid ""
"When models are initialized, all methods are automatically scanned and "
"bridged if they look like models declared in the old API style. This "
"bridging makes them transparently callable from new-API-style methods."
msgstr ""

#: ../../reference/orm.rst:1187
msgid ""
"Methods are matched as \"old-API style\" if their second positional "
"parameter (after ``self``) is called either ``cr`` or ``cursor``. The "
"system also recognizes the third positional parameter being called "
"``uid`` or ``user`` and the fourth being called ``id`` or ``ids``. It "
"also recognizes the presence of any parameter called ``context``."
msgstr ""

#: ../../reference/orm.rst:1193
msgid ""
"When calling such methods from a new API context, the system will "
"automatically fill matched parameters from the current "
":class:`~odoo.api.Environment` (for :attr:`~odoo.api.Environment.cr`, "
":attr:`~odoo.api.Environment.user` and "
":attr:`~odoo.api.Environment.context`) or the current recordset (for "
"``id`` and ``ids``)."
msgstr ""

#: ../../reference/orm.rst:1200
msgid ""
"In the rare cases where it is necessary, the bridging can be customized "
"by decorating the old-style method:"
msgstr ""

#: ../../reference/orm.rst:1203
msgid ""
"disabling it entirely, by decorating a method with "
":func:`~odoo.api.noguess` there will be no bridging and methods will be "
"called the exact same way from the new and old API styles"
msgstr ""

#: ../../reference/orm.rst:1206
msgid ""
"defining the bridge explicitly, this is mostly for methods which are "
"matched incorrectly (because parameters are named in unexpected ways):"
msgstr ""

#: ../../reference/orm.rst:1210
msgid ":func:`~odoo.api.cr`"
msgstr ""

#: ../../reference/orm.rst:1210
msgid ""
"will automatically prepend the current cursor to explicitly provided "
"parameters, positionally"
msgstr ""

#: ../../reference/orm.rst:1213
msgid ":func:`~odoo.api.cr_uid`"
msgstr ""

#: ../../reference/orm.rst:1213
msgid ""
"will automatically prepend the current cursor and user's id to explictly "
"provided parameters"
msgstr ""

#: ../../reference/orm.rst:1216
msgid ":func:`~odoo.api.cr_uid_ids`"
msgstr ""

#: ../../reference/orm.rst:1216
msgid ""
"will automatically prepend the current cursor, user's id and recordset's "
"ids to explicitly provided parameters"
msgstr ""

#: ../../reference/orm.rst:1224
msgid ":func:`~odoo.api.cr_uid_id`"
msgstr ""

#: ../../reference/orm.rst:1219
msgid ""
"will loop over the current recordset and call the method once for each "
"record, prepending the current cursor, user's id and record's id to "
"explicitly provided parameters."
msgstr ""

#: ../../reference/orm.rst:1223
msgid ""
"the result of this wrapper is *always a list* when calling from a new-API"
" context"
msgstr ""

#: ../../reference/orm.rst:1226
msgid ""
"All of these methods have a ``_context``-suffixed version (e.g. "
":func:`~odoo.api.cr_uid_context`) which also passes the current context "
"*by keyword*."
msgstr ""

#: ../../reference/orm.rst:1229
msgid ""
"dual implementations using :func:`~odoo.api.v7` and :func:`~odoo.api.v8` "
"will be ignored as they provide their own \"bridging\""
msgstr ""

#~ msgid ""
#~ "Accessing a relational field "
#~ "(:class:`~openerp.fields.Many2one`, "
#~ ":class:`~openerp.fields.One2many`, "
#~ ":class:`~openerp.fields.Many2many`) *always* returns "
#~ "a recordset, empty if the field is"
#~ " not set."
#~ msgstr ""

#~ msgid ""
#~ "each assignment to a field triggers "
#~ "a database update, when setting multiple"
#~ " fields at the same time or "
#~ "setting fields on multiple records (to"
#~ " the same value), use "
#~ ":meth:`~openerp.models.Model.write`::"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.filtered`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.sorted`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.mapped`"
#~ msgstr ""

#~ msgid ""
#~ "The :class:`~openerp.api.Environment` stores various"
#~ " contextual data used by the ORM: "
#~ "the database cursor (for database "
#~ "queries), the current user (for access"
#~ " rights checking) and the current "
#~ "context (storing arbitrary metadata). The "
#~ "environment also stores caches."
#~ msgstr ""

#~ msgid ""
#~ "All recordsets have an environment, "
#~ "which is immutable, can be accessed "
#~ "using :attr:`~openerp.models.Model.env` and gives"
#~ " access to the current user "
#~ "(:attr:`~openerp.api.Environment.user`), the cursor "
#~ "(:attr:`~openerp.api.Environment.cr`) or the context"
#~ " (:attr:`~openerp.api.Environment.context`)::"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.sudo`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.with_context`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.with_env`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.search`"
#~ msgstr ""

#~ msgid ""
#~ "to just check if any record "
#~ "matches a domain, or count the "
#~ "number of records which do, use "
#~ ":meth:`~openerp.models.Model.search_count`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.create`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.write`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.browse`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.exists`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.api.Environment.ref`"
#~ msgstr ""

#~ msgid ":meth:`~openerp.models.Model.ensure_one`"
#~ msgstr ""

#~ msgid ""
#~ "Fields can be computed (instead of "
#~ "read straight from the database) using"
#~ " the ``compute`` parameter. **It must "
#~ "assign the computed value to the "
#~ "field**. If it uses the values of"
#~ " other *fields*, it should specify "
#~ "those fields using :func:`~openerp.api.depends`::"
#~ msgstr ""

#~ msgid ""
#~ "for non-computed fields, the "
#~ ":func:`~openerp.api.onchange` decorator is used "
#~ "to provide new field values::"
#~ msgstr ""

#~ msgid ""
#~ "The :attr:`~openerp.api.Environment.cr` attribute on"
#~ " environments is the cursor for the"
#~ " current database transaction and allows"
#~ " executing SQL directly, either for "
#~ "queries which are difficult to express"
#~ " using the ORM (e.g. complex joins)"
#~ " or for performance reasons::"
#~ msgstr ""

#~ msgid ""
#~ "Because models use the same cursor "
#~ "and the :class:`~openerp.api.Environment` holds "
#~ "various caches, these caches must be "
#~ "invalidated when *altering* the database "
#~ "in raw SQL, or further uses of "
#~ "models may become incoherent. It is "
#~ "necessary to clear caches when using "
#~ "``CREATE``, ``UPDATE`` or ``DELETE`` in "
#~ "SQL, but not ``SELECT`` (which simply"
#~ " reads the database)."
#~ msgstr ""

#~ msgid ""
#~ "Clearing caches can be performed using"
#~ " the :meth:`~openerp.api.Environment.invalidate_all` "
#~ "method of the :class:`~openerp.api.Environment` "
#~ "object."
#~ msgstr ""

#~ msgid ""
#~ "values of the :class:`~openerp.api.Environment` "
#~ "(cursor, user id and context) are "
#~ "passed explicitly to methods instead"
#~ msgstr ""

#~ msgid ""
#~ "record data (:attr:`~openerp.models.Model.ids`) are"
#~ " passed explicitly to methods, and "
#~ "possibly not passed at all"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.model`"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.multi`"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.returns`"
#~ msgstr ""

#~ msgid "Main super-class for regular database-persisted OpenERP models."
#~ msgstr ""

#~ msgid "OpenERP models are created by inheriting from this class::"
#~ msgstr ""

#~ msgid ""
#~ "Name of the table backing the "
#~ "model created when "
#~ ":attr:`~openerp.models.Model._auto`, automatically "
#~ "generated by default."
#~ msgstr ""

#~ msgid ""
#~ "implements composition-based inheritance: the"
#~ " new model exposes all the fields "
#~ "of the :attr:`~openerp.models.Model._inherits`-ed "
#~ "model but stores none of them: the"
#~ " values themselves remain stored on "
#~ "the linked record."
#~ msgstr ""

#~ msgid ""
#~ "if the same field is defined on"
#~ " multiple :attr:`~openerp.models.Model._inherits`-ed"
#~ msgstr ""

#~ msgid "use :func:`~openerp.api.constrains`"
#~ msgstr ""

#~ msgid ""
#~ "For numeric fields "
#~ "(:class:`~openerp.fields.Integer`, "
#~ ":class:`~openerp.fields.Float`) the value should "
#~ "be of the corresponding type"
#~ msgstr ""

#~ msgid ""
#~ "For :class:`~openerp.fields.Boolean`, the value "
#~ "should be a :class:`python:bool`"
#~ msgstr ""

#~ msgid ""
#~ "For :class:`~openerp.fields.Selection`, the value"
#~ " should match the selection values "
#~ "(generally :class:`python:str`, sometimes "
#~ ":class:`python:int`)"
#~ msgstr ""

#~ msgid ""
#~ "For :class:`~openerp.fields.Many2one`, the value "
#~ "should be the database identifier of "
#~ "the record to set"
#~ msgstr ""

#~ msgid ""
#~ "for historical and compatibility reasons, "
#~ ":class:`~openerp.fields.Date` and "
#~ ":class:`~openerp.fields.Datetime` fields use strings"
#~ " as values (written and read) rather"
#~ " than :class:`~python:datetime.date` or "
#~ ":class:`~python:datetime.datetime`. These date "
#~ "strings are UTC-only and formatted "
#~ "according to "
#~ ":const:`openerp.tools.misc.DEFAULT_SERVER_DATE_FORMAT` and "
#~ ":const:`openerp.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT`"
#~ msgstr ""

#~ msgid ""
#~ ":class:`~openerp.fields.One2many` and "
#~ ":class:`~openerp.fields.Many2many` use a special "
#~ "\"commands\" format to manipulate the "
#~ "set of records stored in/associated with"
#~ " the field."
#~ msgstr ""

#~ msgid ""
#~ "removes the record of id ``id`` "
#~ "from the set, but does not delete"
#~ " it. Can not be used on "
#~ ":class:`~openerp.fields.One2many`. Can not be "
#~ "used in :meth:`~.create`."
#~ msgstr ""

#~ msgid ""
#~ "adds an existing record of id "
#~ "``id`` to the set. Can not be "
#~ "used on :class:`~openerp.fields.One2many`."
#~ msgstr ""

#~ msgid ""
#~ "removes all records from the set, "
#~ "equivalent to using the command ``3``"
#~ " on every record explicitly. Can not"
#~ " be used on :class:`~openerp.fields.One2many`."
#~ " Can not be used in :meth:`~.create`."
#~ msgstr ""

#~ msgid ""
#~ "replaces all existing records in the "
#~ "set by the ``ids`` list, equivalent "
#~ "to using the command ``5`` followed "
#~ "by a command ``4`` for each ``id``"
#~ " in ``ids``. Can not be used on"
#~ " :class:`~openerp.fields.One2many`."
#~ msgstr ""

#~ msgid "Research"
#~ msgstr ""

#~ msgid ""
#~ "either a function of one argument "
#~ "that returns a comparison key for "
#~ "each record, or ``None``, in which "
#~ "case records are ordered according the"
#~ " default model's order"
#~ msgstr ""

#~ msgid ""
#~ "Because the record rules and access "
#~ "control will have to be re-"
#~ "evaluated, the new recordset will not"
#~ " benefit from the current environment's "
#~ "data cache, so later data access "
#~ "may incur extra delays while re-"
#~ "fetching from the database."
#~ msgstr ""

#~ msgid ""
#~ "The new environment will not benefit "
#~ "from the current environment's data "
#~ "cache, so later data access may "
#~ "incur extra delays while re-fetching "
#~ "from the database."
#~ msgstr ""

#~ msgid "???"
#~ msgstr ""

#~ msgid "Duplicate record with given id updating it with default values"
#~ msgstr ""

#~ msgid "Identifier :class:`field <openerp.fields.Field>`"
#~ msgstr ""

#~ msgid ":class:`~openerp.field.Datetime`"
#~ msgstr ""

#~ msgid ":class:`~openerp.fields.Char`"
#~ msgstr ""

#~ msgid ":class:`~openerp.fields.Boolean`"
#~ msgstr ""

#~ msgid ":class:`~openerp.fields.Integer`"
#~ msgstr ""

#~ msgid ""
#~ "lifecycle stages of the object, used "
#~ "by the ``states`` attribute on "
#~ ":class:`fields <openerp.fields.Field>`"
#~ msgstr ""

#~ msgid ":class:`~openerp.fields.Selection`"
#~ msgstr ""

#~ msgid ":class:`~openerp.fields.Many2one`"
#~ msgstr ""

#~ msgid ""
#~ "Should raise :class:`~openerp.exceptions.ValidationError`"
#~ " if the validation failed."
#~ msgstr ""

#~ msgid ""
#~ "It is strongly recommended to use "
#~ ":func:`~.multi` and either iterate on "
#~ "the ``self`` recordset or ensure that"
#~ " the recordset is a single record "
#~ "with :meth:`~openerp.models.Model.ensure_one`."
#~ msgstr ""

#~ msgid ""
#~ "the default value for the field; "
#~ "this is either a static value, or"
#~ " a function taking a recordset and"
#~ " returning a value"
#~ msgstr ""

#~ msgid ""
#~ "The compute method has to assign "
#~ "the field on all records of the"
#~ " invoked recordset. The decorator "
#~ ":meth:`openerp.api.depends` must be applied on"
#~ " the compute method to specify the"
#~ " field dependencies; those dependencies are"
#~ " used to determine when to recompute"
#~ " the field; recomputation is automatic "
#~ "and guarantees cache/database consistency. "
#~ "Note that the same method can be"
#~ " used for several fields, you simply"
#~ " have to assign all the given "
#~ "fields in the method; the method "
#~ "will be invoked once for all those"
#~ " fields."
#~ msgstr ""

#~ msgid ""
#~ "A field is defined as class "
#~ "attribute on a model class. If the"
#~ " model is extended (see "
#~ ":class:`~openerp.models.Model`), one can also "
#~ "extend the field definition by "
#~ "redefining a field with the same "
#~ "name and same type on the "
#~ "subclass. In that case, the attributes"
#~ " of the field are taken from "
#~ "the parent class and overridden by "
#~ "the ones given in subclasses."
#~ msgstr ""

#~ msgid "Bases: :class:`openerp.fields._String`"
#~ msgstr ""

#~ msgid "Bases: :class:`openerp.fields.Field`"
#~ msgstr ""

#~ msgid ""
#~ "Returns the given timestamp converted to"
#~ " the client's timezone. This method "
#~ "is *not* meant for use as a "
#~ "_defaults initializer, because datetime fields"
#~ " are automatically converted upon display"
#~ " on client side. For _defaults you"
#~ " :meth:`fields.datetime.now` should be used "
#~ "instead."
#~ msgstr ""

#~ msgid "Bases: :class:`openerp.fields._Relational`"
#~ msgstr ""

#~ msgid "Bases: :class:`openerp.fields._RelationalMulti`"
#~ msgstr ""

#~ msgid "Bases: :class:`openerp.fields.Selection`"
#~ msgstr ""

#~ msgid ""
#~ "When using the "
#~ ":attr:`~openerp.models.Model._inherit` and "
#~ ":attr:`~openerp.models.Model._name` attributes together,"
#~ " Odoo creates a new model using "
#~ "the existing one (provided via "
#~ ":attr:`~openerp.models.Model._inherit`) as a base."
#~ " The new model gets all the "
#~ "fields, methods and meta-information "
#~ "(defaults & al) from its base."
#~ msgstr ""

#~ msgid ""
#~ "When using :attr:`~openerp.models.Model._inherit` "
#~ "but leaving out :attr:`~openerp.models.Model._name`,"
#~ " the new model replaces the existing"
#~ " one, essentially extending it in-"
#~ "place. This is useful to add new"
#~ " fields or methods to existing models"
#~ " (created in other modules), or to"
#~ " customize or reconfigure them (e.g. "
#~ "to change their default sort order):"
#~ msgstr ""

#~ msgid ""
#~ "The third inheritance mechanism provides "
#~ "more flexibility (it can be altered "
#~ "at runtime) but less power: using "
#~ "the :attr:`~openerp.models.Model._inherits` a model"
#~ " *delegates* the lookup of any field"
#~ " not found on the current model "
#~ "to \"children\" models. The delegation "
#~ "is performed via :class:`~openerp.fields.Reference`"
#~ " fields automatically set up on the"
#~ " parent model:"
#~ msgstr ""

#~ msgid ""
#~ "a field name of the current model,"
#~ " or a relationship traversal through "
#~ "a :class:`~openerp.fields.Many2one` using dot-"
#~ "notation e.g. ``'street'`` or "
#~ "``'partner_id.country'``"
#~ msgstr ""

#~ msgid ""
#~ "Takes the semantics of the model "
#~ "into account (i.e following the "
#~ "relationship field named by "
#~ ":attr:`~openerp.models.Model._parent_name`)."
#~ msgstr ""

#~ msgid ""
#~ ":meth:`~openerp.models.Model.search` returns a "
#~ "recordset, no point in e.g. browsing "
#~ "its result"
#~ msgstr ""

#~ msgid ""
#~ ":func:`~openerp.api.depends` on ``compute=`` methods"
#~ " **must be complete**, it must list"
#~ " **all** the fields and sub-fields"
#~ " which the compute method uses. It"
#~ " is better to have too many "
#~ "dependencies (will recompute the field "
#~ "in cases where that is not needed)"
#~ " than not enough (will forget to "
#~ "recompute the field and then values "
#~ "will be incorrect)"
#~ msgstr ""

#~ msgid ""
#~ "the decorators :func:`~openerp.api.model` and "
#~ ":func:`~openerp.api.multi` are for bridging "
#~ "*when calling from the old API "
#~ "context*, for internal or pure new-"
#~ "api (e.g. compute) they are useless"
#~ msgstr ""

#~ msgid ""
#~ "remove :attr:`~openerp.models.Model._default`, replace "
#~ "by ``default=`` parameter on corresponding "
#~ "fields"
#~ msgstr ""

#~ msgid ""
#~ "the normal new-api import is "
#~ "``from openerp import fields, models``. "
#~ "If compatibility decorators are necessary, "
#~ "use ``from openerp import api, fields,"
#~ " models``"
#~ msgstr ""

#~ msgid ""
#~ "avoid the :func:`~openerp.api.one` decorator, "
#~ "it probably does not do what you"
#~ " expect"
#~ msgstr ""

#~ msgid ""
#~ "remove explicit definition of "
#~ ":attr:`~openerp.models.Model.create_uid`, "
#~ ":attr:`~openerp.models.Model.create_date`, "
#~ ":attr:`~openerp.models.Model.write_uid` and "
#~ ":attr:`~openerp.models.Model.write_date` fields: they "
#~ "are now created as regular "
#~ "\"legitimate\" fields, and can be read"
#~ " and written like any other field "
#~ "out-of-the-box"
#~ msgstr ""

#~ msgid ""
#~ "when straight conversion is impossible "
#~ "(semantics can not be bridged) or "
#~ "the \"old API\" version is not "
#~ "desirable and could be improved for "
#~ "the new API, it is possible to "
#~ "use completely different \"old API\" and"
#~ " \"new API\" implementations for the "
#~ "same method name using :func:`~openerp.api.v7`"
#~ " and :func:`~openerp.api.v8`. The method "
#~ "should first be defined using the "
#~ "old-API style and decorated with "
#~ ":func:`~openerp.api.v7`, it should then be "
#~ "re-defined using the exact same "
#~ "name but the new-API style and "
#~ "decorated with :func:`~openerp.api.v8`. Calls "
#~ "from an old-API context will be"
#~ " dispatched to the first implementation "
#~ "and calls from a new-API context"
#~ " will be dispatched to the second "
#~ "implementation. One implementation can call"
#~ " (and frequently does) call the other"
#~ " by switching context."
#~ msgstr ""

#~ msgid ""
#~ "uses of :attr:`~openerp.models.Model._columns` or"
#~ " :attr:`~openerp.models.Model._all_columns` should be"
#~ " replaced by :attr:`~openerp.models.Model._fields`, "
#~ "which provides access to instances of"
#~ " new-style :class:`openerp.fields.Field` "
#~ "instances (rather than old-style "
#~ ":class:`openerp.osv.fields._column`)."
#~ msgstr ""

#~ msgid ""
#~ "Non-stored computed fields created using"
#~ " the new API style are *not* "
#~ "available in :attr:`~openerp.models.Model._columns` "
#~ "and can only be inspected through "
#~ ":attr:`~openerp.models.Model._fields`"
#~ msgstr ""

#~ msgid ""
#~ ":class:`~openerp.api.Environment` objects rely on"
#~ " some threadlocal state, which has to"
#~ " be set up before using them. "
#~ "It is necessary to do so using "
#~ "the :meth:`openerp.api.Environment.manage` context "
#~ "manager when trying to use the new"
#~ " API in contexts where it hasn't "
#~ "been set up yet, such as new "
#~ "threads or a Python interactive "
#~ "environment::"
#~ msgstr ""

#~ msgid ""
#~ "When calling such methods from a "
#~ "new API context, the system will "
#~ "automatically fill matched parameters from "
#~ "the current :class:`~openerp.api.Environment` (for"
#~ " :attr:`~openerp.api.Environment.cr`, "
#~ ":attr:`~openerp.api.Environment.user` and "
#~ ":attr:`~openerp.api.Environment.context`) or the "
#~ "current recordset (for ``id`` and "
#~ "``ids``)."
#~ msgstr ""

#~ msgid ""
#~ "disabling it entirely, by decorating a"
#~ " method with :func:`~openerp.api.noguess` there"
#~ " will be no bridging and methods "
#~ "will be called the exact same way"
#~ " from the new and old API "
#~ "styles"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.cr`"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.cr_uid`"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.cr_uid_ids`"
#~ msgstr ""

#~ msgid ":func:`~openerp.api.cr_uid_id`"
#~ msgstr ""

#~ msgid ""
#~ "All of these methods have a "
#~ "``_context``-suffixed version (e.g. "
#~ ":func:`~openerp.api.cr_uid_context`) which also "
#~ "passes the current context *by keyword*."
#~ msgstr ""

#~ msgid ""
#~ "dual implementations using :func:`~openerp.api.v7`"
#~ " and :func:`~openerp.api.v8` will be "
#~ "ignored as they provide their own "
#~ "\"bridging\""
#~ msgstr ""

# 010b21e008c54fc59aa6cbf041c6eb2f
#~ msgid ""
#~ "Recordsets provide an \"Active Record\" "
#~ "interface: model fields can be read "
#~ "and written directly from the record,"
#~ " but only on singletons (single-"
#~ "record recordsets). Setting a field's "
#~ "value triggers an update to the "
#~ "database::"
#~ msgstr ""

# 5b7301ace8014377bb71e69053ada9c0
#~ msgid "[{'field_name_1': value, ...]"
#~ msgstr ""

# 0ff34465d8ec455d9704e9e71798556e
#~ msgid "list"
#~ msgstr ""

# 2f302af411634911acb3299c4a07da91
#~ msgid "list(tuple)"
#~ msgstr ""

# ed0b9348b2644b8fa59bbfd0361b7704
#~ msgid "tuple"
#~ msgstr ""

# 9862a13888ca45e5a31a3af883a8d97b
#~ msgid "Sparse fields"
#~ msgstr ""

# 695b15cdc5b046c99862473c2cf42716
#~ msgid ""
#~ "Sparse fields have a very small "
#~ "probability of being not null. Therefore"
#~ " many such fields can be serialized"
#~ " compactly into a common location, "
#~ "the latter being a so-called "
#~ "\"serialized\" field."
#~ msgstr ""

# a11a7542566e47339348f8c73910426e
#~ msgid "the name of the field where the value of this field must be stored."
#~ msgstr ""

# 716a9da477774821a9ca1b6d1cd32053
#~ msgid "datetime"
#~ msgstr ""

